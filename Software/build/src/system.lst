   1               		.file	"system.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	timer_register_callback
  13               	timer_register_callback:
  14               	.LVL0:
  15               	.LFB22:
  16               		.file 1 "src/system.c"
   1:src/system.c  **** #include "system.h"
   2:src/system.c  **** 
   3:src/system.c  **** static volatile unsigned long sys_time;
   4:src/system.c  **** static void (*timer_callback)(void) = NULL;
   5:src/system.c  **** 
   6:src/system.c  **** static void init_switches(void);
   7:src/system.c  **** static void init_led(void);
   8:src/system.c  **** static void timer_init(unsigned int freq);
   9:src/system.c  **** 
  10:src/system.c  **** /*
  11:src/system.c  ****  * Function:        void timer_register_callback(void (*callback)(void))
  12:src/system.c  ****  * Description:     assign function to timer callback
  13:src/system.c  ****  */
  14:src/system.c  **** void timer_register_callback(void (*callback)(void))
  15:src/system.c  **** {
  17               		.loc 1 15 1 view -0
  18               		.cfi_startproc
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  16:src/system.c  ****     timer_callback = callback;
  23               		.loc 1 16 5 view .LVU1
  24               		.loc 1 16 20 is_stmt 0 view .LVU2
  25 0000 9093 0000 		sts timer_callback+1,r25
  26 0004 8093 0000 		sts timer_callback,r24
  27               	/* epilogue start */
  17:src/system.c  **** } // end of timer_register_callback()
  28               		.loc 1 17 1 view .LVU3
  29 0008 0895      		ret
  30               		.cfi_endproc
  31               	.LFE22:
  33               	.global	__vector_12
  35               	__vector_12:
  36               	.LFB24:
  18:src/system.c  **** 
  19:src/system.c  **** /*
  20:src/system.c  ****  * Function:        static void timer_init(unsigned int freq)
  21:src/system.c  ****  * Description:     setup the timer by `freq`
  22:src/system.c  ****  */
  23:src/system.c  **** static void timer_init(unsigned int freq)
  24:src/system.c  **** {
  25:src/system.c  ****     TCCR1A = 0;
  26:src/system.c  **** 	TCCR1B = (1 << WGM12) | (1 << CS10);
  27:src/system.c  **** 	OCR1A = (double)F_CPU / (double)freq + 0.5;
  28:src/system.c  **** 	TIMSK1 = 1 << OCIE1A;
  29:src/system.c  **** 
  30:src/system.c  **** 	SREG |= 0x80;
  31:src/system.c  **** } // end of timer_init()
  32:src/system.c  **** 
  33:src/system.c  **** ISR(TIMER1_COMPA_vect)
  34:src/system.c  **** {
  37               		.loc 1 34 1 is_stmt 1 view -0
  38               		.cfi_startproc
  39 000a 1F92      		push r1
  40               	.LCFI0:
  41               		.cfi_def_cfa_offset 3
  42               		.cfi_offset 1, -2
  43 000c 0F92      		push r0
  44               	.LCFI1:
  45               		.cfi_def_cfa_offset 4
  46               		.cfi_offset 0, -3
  47 000e 0FB6      		in r0,__SREG__
  48 0010 0F92      		push r0
  49 0012 1124      		clr __zero_reg__
  50 0014 0BB6      		in r0,__RAMPZ__
  51 0016 0F92      		push r0
  52 0018 2F93      		push r18
  53               	.LCFI2:
  54               		.cfi_def_cfa_offset 5
  55               		.cfi_offset 18, -4
  56 001a 3F93      		push r19
  57               	.LCFI3:
  58               		.cfi_def_cfa_offset 6
  59               		.cfi_offset 19, -5
  60 001c 4F93      		push r20
  61               	.LCFI4:
  62               		.cfi_def_cfa_offset 7
  63               		.cfi_offset 20, -6
  64 001e 5F93      		push r21
  65               	.LCFI5:
  66               		.cfi_def_cfa_offset 8
  67               		.cfi_offset 21, -7
  68 0020 6F93      		push r22
  69               	.LCFI6:
  70               		.cfi_def_cfa_offset 9
  71               		.cfi_offset 22, -8
  72 0022 7F93      		push r23
  73               	.LCFI7:
  74               		.cfi_def_cfa_offset 10
  75               		.cfi_offset 23, -9
  76 0024 8F93      		push r24
  77               	.LCFI8:
  78               		.cfi_def_cfa_offset 11
  79               		.cfi_offset 24, -10
  80 0026 9F93      		push r25
  81               	.LCFI9:
  82               		.cfi_def_cfa_offset 12
  83               		.cfi_offset 25, -11
  84 0028 AF93      		push r26
  85               	.LCFI10:
  86               		.cfi_def_cfa_offset 13
  87               		.cfi_offset 26, -12
  88 002a BF93      		push r27
  89               	.LCFI11:
  90               		.cfi_def_cfa_offset 14
  91               		.cfi_offset 27, -13
  92 002c EF93      		push r30
  93               	.LCFI12:
  94               		.cfi_def_cfa_offset 15
  95               		.cfi_offset 30, -14
  96 002e FF93      		push r31
  97               	.LCFI13:
  98               		.cfi_def_cfa_offset 16
  99               		.cfi_offset 31, -15
 100               	/* prologue: Signal */
 101               	/* frame size = 0 */
 102               	/* stack size = 16 */
 103               	.L__stack_usage = 16
  35:src/system.c  ****     // if timer_callback function is set, execute it
  36:src/system.c  ****     if(timer_callback != NULL)
 104               		.loc 1 36 5 view .LVU5
 105               		.loc 1 36 23 is_stmt 0 view .LVU6
 106 0030 E091 0000 		lds r30,timer_callback
 107 0034 F091 0000 		lds r31,timer_callback+1
 108               		.loc 1 36 7 view .LVU7
 109 0038 3097      		sbiw r30,0
 110 003a 01F0      		breq .L3
  37:src/system.c  ****         timer_callback();
 111               		.loc 1 37 9 is_stmt 1 view .LVU8
 112 003c 0995      		icall
 113               	.LVL1:
 114               	.L3:
  38:src/system.c  **** 
  39:src/system.c  ****     // increment sys_time
  40:src/system.c  ****     sys_time++;
 115               		.loc 1 40 5 view .LVU9
 116               		.loc 1 40 13 is_stmt 0 view .LVU10
 117 003e 8091 0000 		lds r24,sys_time
 118 0042 9091 0000 		lds r25,sys_time+1
 119 0046 A091 0000 		lds r26,sys_time+2
 120 004a B091 0000 		lds r27,sys_time+3
 121 004e 0196      		adiw r24,1
 122 0050 A11D      		adc r26,__zero_reg__
 123 0052 B11D      		adc r27,__zero_reg__
 124 0054 8093 0000 		sts sys_time,r24
 125 0058 9093 0000 		sts sys_time+1,r25
 126 005c A093 0000 		sts sys_time+2,r26
 127 0060 B093 0000 		sts sys_time+3,r27
 128               	/* epilogue start */
  41:src/system.c  **** 
  42:src/system.c  **** }
 129               		.loc 1 42 1 view .LVU11
 130 0064 FF91      		pop r31
 131 0066 EF91      		pop r30
 132 0068 BF91      		pop r27
 133 006a AF91      		pop r26
 134 006c 9F91      		pop r25
 135 006e 8F91      		pop r24
 136 0070 7F91      		pop r23
 137 0072 6F91      		pop r22
 138 0074 5F91      		pop r21
 139 0076 4F91      		pop r20
 140 0078 3F91      		pop r19
 141 007a 2F91      		pop r18
 142 007c 0F90      		pop r0
 143 007e 0BBE      		out __RAMPZ__,r0
 144 0080 0F90      		pop r0
 145 0082 0FBE      		out __SREG__,r0
 146 0084 0F90      		pop r0
 147 0086 1F90      		pop r1
 148 0088 1895      		reti
 149               		.cfi_endproc
 150               	.LFE24:
 152               		.section	.rodata.str1.1,"aMS",@progbits,1
 153               	.LC0:
 154 0000 5345 4E53 		.string	"SENSA - Motor control board - DEBUG \n\n"
 154      4120 2D20 
 154      4D6F 746F 
 154      7220 636F 
 154      6E74 726F 
 155               	.LC1:
 156 0027 5374 6172 		.string	"Starting init... "
 156      7469 6E67 
 156      2069 6E69 
 156      742E 2E2E 
 156      2000 
 157               	.LC2:
 158 0039 6669 6E69 		.string	"finished... \n\n"
 158      7368 6564 
 158      2E2E 2E20 
 158      0A0A 00
 159               		.text
 160               	.global	system_init
 162               	system_init:
 163               	.LFB25:
  43:src/system.c  **** 
  44:src/system.c  **** /*
  45:src/system.c  ****  * Function:        void system_init(void)
  46:src/system.c  ****  * Description:     init everything that is needed
  47:src/system.c  ****  */
  48:src/system.c  **** void system_init(void) {
 164               		.loc 1 48 24 is_stmt 1 view -0
 165               		.cfi_startproc
 166 008a CF93      		push r28
 167               	.LCFI14:
 168               		.cfi_def_cfa_offset 3
 169               		.cfi_offset 28, -2
 170 008c DF93      		push r29
 171               	.LCFI15:
 172               		.cfi_def_cfa_offset 4
 173               		.cfi_offset 29, -3
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 2 */
 177               	.L__stack_usage = 2
  49:src/system.c  **** 
  50:src/system.c  ****     #ifdef DEBUG
  51:src/system.c  ****         USART0_init(9600);
 178               		.loc 1 51 9 view .LVU13
 179 008e 60E8      		ldi r22,lo8(-128)
 180 0090 75E2      		ldi r23,lo8(37)
 181 0092 80E0      		ldi r24,0
 182 0094 90E0      		ldi r25,0
 183 0096 0E94 0000 		call USART0_init
 184               	.LVL2:
  52:src/system.c  ****     #endif
  53:src/system.c  ****     debug_printf("SENSA - Motor control board - DEBUG \n\n");
 185               		.loc 1 53 5 view .LVU14
 186 009a 80E0      		ldi r24,lo8(.LC0)
 187 009c 90E0      		ldi r25,hi8(.LC0)
 188 009e 0E94 0000 		call debug_printf
 189               	.LVL3:
  54:src/system.c  ****     debug_printf("Starting init... ");
 190               		.loc 1 54 5 view .LVU15
 191 00a2 80E0      		ldi r24,lo8(.LC1)
 192 00a4 90E0      		ldi r25,hi8(.LC1)
 193 00a6 0E94 0000 		call debug_printf
 194               	.LVL4:
  55:src/system.c  ****     
  56:src/system.c  ****     init_led();
 195               		.loc 1 56 5 view .LVU16
 196               	.LBB15:
 197               	.LBI15:
  57:src/system.c  **** 
  58:src/system.c  ****     // indicate the beginning of the init
  59:src/system.c  ****     gpio_write_pin(PIN_LED1, HIGH);                       
  60:src/system.c  **** 
  61:src/system.c  ****     CAN_Init();
  62:src/system.c  **** 	CAN_InitRxMob(MOTOR_CONTROL_CAN_ID);
  63:src/system.c  **** 
  64:src/system.c  ****     // timer callback for debouncing inputs
  65:src/system.c  ****     timer_register_callback(gpio_debouncer);
  66:src/system.c  **** 
  67:src/system.c  ****     // timer set to 1000hz
  68:src/system.c  ****     timer_init(1000);
  69:src/system.c  **** 
  70:src/system.c  **** 
  71:src/system.c  ****     // Stepper Init
  72:src/system.c  ****     init_stepper();
  73:src/system.c  **** 
  74:src/system.c  ****     // DC Motor Init
  75:src/system.c  ****     init_hbridge();
  76:src/system.c  **** 
  77:src/system.c  ****     // Encoder Init
  78:src/system.c  **** 
  79:src/system.c  ****     // Switches Init
  80:src/system.c  ****     init_switches();
  81:src/system.c  **** 
  82:src/system.c  ****     // end of init
  83:src/system.c  ****     gpio_write_pin(PIN_LED1, LOW); 
  84:src/system.c  **** 
  85:src/system.c  ****     debug_printf("finished... \n\n");
  86:src/system.c  **** }
  87:src/system.c  **** 
  88:src/system.c  **** 
  89:src/system.c  **** /************************************************************/
  90:src/system.c  **** /*                   Helper functions                       */
  91:src/system.c  **** /************************************************************/
  92:src/system.c  **** 
  93:src/system.c  **** /*
  94:src/system.c  ****  * Function:   void delay(int ms)
  95:src/system.c  ****  * Parameter:  int ms - the amount of miliseconds we need to delay
  96:src/system.c  ****  */
  97:src/system.c  **** void delay(int ms)
  98:src/system.c  **** {
  99:src/system.c  ****   while (0 < ms)
 100:src/system.c  ****   {  
 101:src/system.c  ****     _delay_ms(1);
 102:src/system.c  ****     --ms;
 103:src/system.c  ****   }
 104:src/system.c  **** } // end of delay(int ms)
 105:src/system.c  **** 
 106:src/system.c  **** /************************************************************/
 107:src/system.c  **** /*                  LED debug section                       */
 108:src/system.c  **** /************************************************************/
 109:src/system.c  **** 
 110:src/system.c  **** /*
 111:src/system.c  ****  * Function:   void init_led(void)
 112:src/system.c  ****  * Parameter:  init the pins for the LEDs
 113:src/system.c  ****  */
 114:src/system.c  **** static void init_led(void) {
 198               		.loc 1 114 13 view .LVU17
 199               	.LBB16:
 115:src/system.c  **** 
 116:src/system.c  ****     gpio_register_pin(PIN_LED1, GPIO_DIRECTION_OUTPUT, true);      // set led1 as output
 200               		.loc 1 116 5 view .LVU18
 201 00aa 41E0      		ldi r20,lo8(1)
 202 00ac 61E0      		ldi r22,lo8(1)
 203 00ae 80E3      		ldi r24,lo8(48)
 204 00b0 0E94 0000 		call gpio_register_pin
 205               	.LVL5:
 117:src/system.c  ****     gpio_register_pin(PIN_LED2, GPIO_DIRECTION_OUTPUT, true);      // set led2 as output
 206               		.loc 1 117 5 view .LVU19
 207 00b4 41E0      		ldi r20,lo8(1)
 208 00b6 61E0      		ldi r22,lo8(1)
 209 00b8 81E3      		ldi r24,lo8(49)
 210 00ba 0E94 0000 		call gpio_register_pin
 211               	.LVL6:
 118:src/system.c  **** 
 119:src/system.c  ****     gpio_write_pin(PIN_LED1, LOW);                                  // set led1 low
 212               		.loc 1 119 5 view .LVU20
 213 00be 60E0      		ldi r22,0
 214 00c0 80E3      		ldi r24,lo8(48)
 215 00c2 0E94 0000 		call gpio_write_pin
 216               	.LVL7:
 120:src/system.c  ****     gpio_write_pin(PIN_LED2, LOW);                                  // set led2 low
 217               		.loc 1 120 5 view .LVU21
 218 00c6 60E0      		ldi r22,0
 219 00c8 81E3      		ldi r24,lo8(49)
 220 00ca 0E94 0000 		call gpio_write_pin
 221               	.LVL8:
 222               	.LBE16:
 223               	.LBE15:
  59:src/system.c  **** 
 224               		.loc 1 59 5 view .LVU22
 225 00ce 61E0      		ldi r22,lo8(1)
 226 00d0 80E3      		ldi r24,lo8(48)
 227 00d2 0E94 0000 		call gpio_write_pin
 228               	.LVL9:
  61:src/system.c  **** 	CAN_InitRxMob(MOTOR_CONTROL_CAN_ID);
 229               		.loc 1 61 5 view .LVU23
 230 00d6 0E94 0000 		call CAN_Init
 231               	.LVL10:
  62:src/system.c  **** 
 232               		.loc 1 62 2 view .LVU24
 233 00da 84ED      		ldi r24,lo8(-44)
 234 00dc 90E0      		ldi r25,0
 235 00de 0E94 0000 		call CAN_InitRxMob
 236               	.LVL11:
  65:src/system.c  **** 
 237               		.loc 1 65 5 view .LVU25
 238               	.LBB17:
 239               	.LBI17:
  14:src/system.c  **** {
 240               		.loc 1 14 6 view .LVU26
 241               	.LBB18:
  16:src/system.c  **** } // end of timer_register_callback()
 242               		.loc 1 16 5 view .LVU27
  16:src/system.c  **** } // end of timer_register_callback()
 243               		.loc 1 16 20 is_stmt 0 view .LVU28
 244 00e2 80E0      		ldi r24,lo8(gs(gpio_debouncer))
 245 00e4 90E0      		ldi r25,hi8(gs(gpio_debouncer))
 246 00e6 9093 0000 		sts timer_callback+1,r25
 247 00ea 8093 0000 		sts timer_callback,r24
 248               	.LVL12:
  16:src/system.c  **** } // end of timer_register_callback()
 249               		.loc 1 16 20 view .LVU29
 250               	.LBE18:
 251               	.LBE17:
  68:src/system.c  **** 
 252               		.loc 1 68 5 is_stmt 1 view .LVU30
 253               	.LBB19:
 254               	.LBI19:
  23:src/system.c  **** {
 255               		.loc 1 23 13 view .LVU31
 256               	.LBB20:
  25:src/system.c  **** 	TCCR1B = (1 << WGM12) | (1 << CS10);
 257               		.loc 1 25 5 view .LVU32
  25:src/system.c  **** 	TCCR1B = (1 << WGM12) | (1 << CS10);
 258               		.loc 1 25 12 is_stmt 0 view .LVU33
 259 00ee 1092 8000 		sts 128,__zero_reg__
  26:src/system.c  **** 	OCR1A = (double)F_CPU / (double)freq + 0.5;
 260               		.loc 1 26 2 is_stmt 1 view .LVU34
  26:src/system.c  **** 	OCR1A = (double)F_CPU / (double)freq + 0.5;
 261               		.loc 1 26 9 is_stmt 0 view .LVU35
 262 00f2 89E0      		ldi r24,lo8(9)
 263 00f4 8093 8100 		sts 129,r24
  27:src/system.c  **** 	TIMSK1 = 1 << OCIE1A;
 264               		.loc 1 27 2 is_stmt 1 view .LVU36
  27:src/system.c  **** 	TIMSK1 = 1 << OCIE1A;
 265               		.loc 1 27 8 is_stmt 0 view .LVU37
 266 00f8 80E8      		ldi r24,lo8(-128)
 267 00fa 9EE3      		ldi r25,lo8(62)
 268 00fc 9093 8900 		sts 136+1,r25
 269 0100 8093 8800 		sts 136,r24
  28:src/system.c  **** 
 270               		.loc 1 28 2 is_stmt 1 view .LVU38
  28:src/system.c  **** 
 271               		.loc 1 28 9 is_stmt 0 view .LVU39
 272 0104 82E0      		ldi r24,lo8(2)
 273 0106 8093 6F00 		sts 111,r24
  30:src/system.c  **** } // end of timer_init()
 274               		.loc 1 30 2 is_stmt 1 view .LVU40
  30:src/system.c  **** } // end of timer_init()
 275               		.loc 1 30 7 is_stmt 0 view .LVU41
 276 010a 8FB7      		in r24,__SREG__
 277 010c 8068      		ori r24,lo8(-128)
 278 010e 8FBF      		out __SREG__,r24
 279               	.LVL13:
  30:src/system.c  **** } // end of timer_init()
 280               		.loc 1 30 7 view .LVU42
 281               	.LBE20:
 282               	.LBE19:
  72:src/system.c  **** 
 283               		.loc 1 72 5 is_stmt 1 view .LVU43
 284 0110 0E94 0000 		call init_stepper
 285               	.LVL14:
  75:src/system.c  **** 
 286               		.loc 1 75 5 view .LVU44
 287 0114 0E94 0000 		call init_hbridge
 288               	.LVL15:
  80:src/system.c  **** 
 289               		.loc 1 80 5 view .LVU45
 290               	.LBB21:
 291               	.LBI21:
 121:src/system.c  ****     
 122:src/system.c  **** } // end of init_led(void)
 123:src/system.c  **** 
 124:src/system.c  **** 
 125:src/system.c  **** /************************************************************/
 126:src/system.c  **** /*                   Switches section                       */
 127:src/system.c  **** /************************************************************/
 128:src/system.c  **** 
 129:src/system.c  **** uint8_t switches_pin[8] = {40,41,42,43,44,45,46,47};
 130:src/system.c  **** 
 131:src/system.c  **** /*
 132:src/system.c  ****  * Function:   static void init_switches()
 133:src/system.c  ****  * Parameter:  init pins for switches (switches_pin)
 134:src/system.c  ****  */
 135:src/system.c  **** static void init_switches(void) {
 292               		.loc 1 135 13 view .LVU46
 293               		.loc 1 135 13 is_stmt 0 view .LVU47
 294 0118 C0E0      		ldi r28,lo8(switches_pin)
 295 011a D0E0      		ldi r29,hi8(switches_pin)
 296               	.LVL16:
 297               	.L8:
 298               	.LBB22:
 136:src/system.c  ****     for(int i=0; i < 8; i++) {
 137:src/system.c  ****         gpio_register_pin(switches_pin[i], GPIO_DIRECTION_INPUT, false);
 299               		.loc 1 137 9 is_stmt 1 view .LVU48
 300 011c 40E0      		ldi r20,0
 301 011e 60E0      		ldi r22,0
 302 0120 8991      		ld r24,Y+
 303               	.LVL17:
 304               		.loc 1 137 9 is_stmt 0 view .LVU49
 305 0122 0E94 0000 		call gpio_register_pin
 306               	.LVL18:
 136:src/system.c  ****     for(int i=0; i < 8; i++) {
 307               		.loc 1 136 5 view .LVU50
 308 0126 80E0      		ldi r24,hi8(switches_pin+8)
 309 0128 C030      		cpi r28,lo8(switches_pin+8)
 310 012a D807      		cpc r29,r24
 311 012c 01F4      		brne .L8
 312               	.LVL19:
 136:src/system.c  ****     for(int i=0; i < 8; i++) {
 313               		.loc 1 136 5 view .LVU51
 314               	.LBE22:
 315               	.LBE21:
  83:src/system.c  **** 
 316               		.loc 1 83 5 is_stmt 1 view .LVU52
 317 012e 60E0      		ldi r22,0
 318 0130 80E3      		ldi r24,lo8(48)
 319 0132 0E94 0000 		call gpio_write_pin
 320               	.LVL20:
  85:src/system.c  **** }
 321               		.loc 1 85 5 view .LVU53
 322 0136 80E0      		ldi r24,lo8(.LC2)
 323 0138 90E0      		ldi r25,hi8(.LC2)
 324               	/* epilogue start */
  86:src/system.c  **** 
 325               		.loc 1 86 1 is_stmt 0 view .LVU54
 326 013a DF91      		pop r29
 327 013c CF91      		pop r28
  85:src/system.c  **** }
 328               		.loc 1 85 5 view .LVU55
 329 013e 0C94 0000 		jmp debug_printf
 330               	.LVL21:
 331               		.cfi_endproc
 332               	.LFE25:
 334               	.global	delay
 336               	delay:
 337               	.LVL22:
 338               	.LFB26:
  98:src/system.c  ****   while (0 < ms)
 339               		.loc 1 98 1 is_stmt 1 view -0
 340               		.cfi_startproc
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
  99:src/system.c  ****   {  
 345               		.loc 1 99 3 view .LVU57
 346               	.L11:
  99:src/system.c  ****   {  
 347               		.loc 1 99 9 is_stmt 0 view .LVU58
 348 0142 1816      		cp __zero_reg__,r24
 349 0144 1906      		cpc __zero_reg__,r25
 350 0146 04F0      		brlt .L12
 351               	/* epilogue start */
 104:src/system.c  **** 
 352               		.loc 1 104 1 view .LVU59
 353 0148 0895      		ret
 354               	.L12:
 101:src/system.c  ****     --ms;
 355               		.loc 1 101 5 is_stmt 1 view .LVU60
 356               	.LVL23:
 357               	.LBB23:
 358               	.LBI23:
 359               		.file 2 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 360               		.loc 2 166 1 view .LVU61
 361               	.LBB24:
 167:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	double __tmp ;
 362               		.loc 2 168 2 view .LVU62
 169:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 363               		.loc 2 172 2 view .LVU63
 173:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 364               		.loc 2 173 2 view .LVU64
 174:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 365               		.loc 2 174 2 view .LVU65
 175:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 366               		.loc 2 184 3 view .LVU66
 185:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/8.3.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 367               		.loc 2 187 2 view .LVU67
 368 014a EFE9      		ldi r30,lo8(3999)
 369 014c FFE0      		ldi r31,hi8(3999)
 370 014e 3197      	1:	sbiw r30,1
 371 0150 01F4      		brne 1b
 372 0152 00C0      		rjmp .
 373 0154 0000      		nop
 374               	.LVL24:
 375               		.loc 2 187 2 is_stmt 0 view .LVU68
 376               	.LBE24:
 377               	.LBE23:
 102:src/system.c  ****   }
 378               		.loc 1 102 5 is_stmt 1 view .LVU69
 379 0156 0197      		sbiw r24,1
 380               	.LVL25:
 102:src/system.c  ****   }
 381               		.loc 1 102 5 is_stmt 0 view .LVU70
 382 0158 00C0      		rjmp .L11
 383               		.cfi_endproc
 384               	.LFE26:
 386               	.global	read_switch
 388               	read_switch:
 389               	.LVL26:
 390               	.LFB29:
 138:src/system.c  ****     }
 139:src/system.c  **** } // end of init_switches()
 140:src/system.c  **** 
 141:src/system.c  **** /*
 142:src/system.c  ****  * Function:   uint8_t read_switch(uint8_t num)
 143:src/system.c  ****  * Parameter:  read `num` switch
 144:src/system.c  ****  */
 145:src/system.c  **** uint8_t read_switch(uint8_t num) {
 391               		.loc 1 145 34 is_stmt 1 view -0
 392               		.cfi_startproc
 393               	/* prologue: function */
 394               	/* frame size = 0 */
 395               	/* stack size = 0 */
 396               	.L__stack_usage = 0
 146:src/system.c  **** 
 147:src/system.c  ****     return gpio_read_pin(switches_pin[num] - 1);
 397               		.loc 1 147 5 view .LVU72
 398               		.loc 1 147 38 is_stmt 0 view .LVU73
 399 015a E82F      		mov r30,r24
 400 015c F0E0      		ldi r31,0
 401 015e E050      		subi r30,lo8(-(switches_pin))
 402 0160 F040      		sbci r31,hi8(-(switches_pin))
 403               		.loc 1 147 12 view .LVU74
 404 0162 8081      		ld r24,Z
 405               	.LVL27:
 406               		.loc 1 147 12 view .LVU75
 407 0164 8150      		subi r24,lo8(-(-1))
 408 0166 0C94 0000 		jmp gpio_read_pin
 409               	.LVL28:
 410               		.cfi_endproc
 411               	.LFE29:
 413               	.global	switches_pin
 414               		.data
 417               	switches_pin:
 418 0000 28        		.byte	40
 419 0001 29        		.byte	41
 420 0002 2A        		.byte	42
 421 0003 2B        		.byte	43
 422 0004 2C        		.byte	44
 423 0005 2D        		.byte	45
 424 0006 2E        		.byte	46
 425 0007 2F        		.byte	47
 426               		.local	timer_callback
 427               		.comm	timer_callback,2,1
 428               		.local	sys_time
 429               		.comm	sys_time,4,1
 430               		.text
 431               	.Letext0:
 432               		.file 3 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdint.h"
 433               		.file 4 "/usr/local/Cellar/avr-gcc/8.3.0/lib/avr-gcc/8/gcc/avr/8.3.0/include/stddef.h"
 434               		.file 5 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdio.h"
 435               		.file 6 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdlib.h"
 436               		.file 7 "src/gpio.h"
 437               		.file 8 "src/Uart.h"
 438               		.file 9 "src/can.h"
 439               		.file 10 "src/stepper.h"
 440               		.file 11 "src/hbridge.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 system.c
/var/tmp//ccPdK4xZ.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//ccPdK4xZ.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//ccPdK4xZ.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//ccPdK4xZ.s:5      *ABS*:000000000000003b __RAMPZ__
/var/tmp//ccPdK4xZ.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//ccPdK4xZ.s:7      *ABS*:0000000000000001 __zero_reg__
/var/tmp//ccPdK4xZ.s:13     .text:0000000000000000 timer_register_callback
                             .bss:0000000000000000 timer_callback
/var/tmp//ccPdK4xZ.s:35     .text:000000000000000a __vector_12
/var/tmp//ccPdK4xZ.s:427    .bss:0000000000000002 sys_time
/var/tmp//ccPdK4xZ.s:162    .text:000000000000008a system_init
/var/tmp//ccPdK4xZ.s:417    .data:0000000000000000 switches_pin
/var/tmp//ccPdK4xZ.s:336    .text:0000000000000142 delay
/var/tmp//ccPdK4xZ.s:388    .text:000000000000015a read_switch

UNDEFINED SYMBOLS
USART0_init
debug_printf
gpio_register_pin
gpio_write_pin
CAN_Init
CAN_InitRxMob
gpio_debouncer
init_stepper
init_hbridge
gpio_read_pin
__do_copy_data
__do_clear_bss
