   1               		.file	"can.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	__vector_18
  13               	__vector_18:
  14               	.LFB0:
  15               		.file 1 "src/can.c"
   1:src/can.c     **** #include "can.h"
   2:src/can.c     **** #include <avr/io.h>
   3:src/can.c     **** #include <avr/interrupt.h>
   4:src/can.c     **** 
   5:src/can.c     **** 
   6:src/can.c     **** // unutrasnje promenljive koje sluze za komunikaciju
   7:src/can.c     **** // svaka poruka sadrzi 8 bajtova podataka i identifikator poruke
   8:src/can.c     **** static volatile canMsg rxBuffer[RX_BUFFER_SIZE];
   9:src/can.c     **** static volatile unsigned char rxRdIndex = 0;
  10:src/can.c     **** static volatile unsigned char rxWrIndex = 0;
  11:src/can.c     **** static volatile unsigned char rxCounter = 0;
  12:src/can.c     **** 
  13:src/can.c     **** // Interrupt Service Routine
  14:src/can.c     **** ISR(CANIT_vect)
  15:src/can.c     **** {
  16               		.loc 1 15 0
  17               		.cfi_startproc
  18 0000 1F92      		push r1
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 1, -2
  22 0002 0F92      		push r0
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 0, -3
  26 0004 0FB6      		in r0,__SREG__
  27 0006 0F92      		push r0
  28 0008 1124      		clr __zero_reg__
  29 000a 0BB6      		in r0,__RAMPZ__
  30 000c 0F92      		push r0
  31 000e 2F93      		push r18
  32               	.LCFI2:
  33               		.cfi_def_cfa_offset 5
  34               		.cfi_offset 18, -4
  35 0010 3F93      		push r19
  36               	.LCFI3:
  37               		.cfi_def_cfa_offset 6
  38               		.cfi_offset 19, -5
  39 0012 4F93      		push r20
  40               	.LCFI4:
  41               		.cfi_def_cfa_offset 7
  42               		.cfi_offset 20, -6
  43 0014 5F93      		push r21
  44               	.LCFI5:
  45               		.cfi_def_cfa_offset 8
  46               		.cfi_offset 21, -7
  47 0016 8F93      		push r24
  48               	.LCFI6:
  49               		.cfi_def_cfa_offset 9
  50               		.cfi_offset 24, -8
  51 0018 9F93      		push r25
  52               	.LCFI7:
  53               		.cfi_def_cfa_offset 10
  54               		.cfi_offset 25, -9
  55 001a EF93      		push r30
  56               	.LCFI8:
  57               		.cfi_def_cfa_offset 11
  58               		.cfi_offset 30, -10
  59 001c FF93      		push r31
  60               	.LCFI9:
  61               		.cfi_def_cfa_offset 12
  62               		.cfi_offset 31, -11
  63               	/* prologue: Signal */
  64               	/* frame size = 0 */
  65               	/* stack size = 12 */
  66               	.L__stack_usage = 12
  16:src/can.c     **** 	unsigned char tempPage = CANPAGE;
  67               		.loc 1 16 0
  68 001e 3091 ED00 		lds r19,237
  69               	.LVL0:
  17:src/can.c     **** 	unsigned char ch;
  18:src/can.c     **** 
  19:src/can.c     **** 	// prolazim redom kroz MOb- ove i gledam da li se nesto dogadja
  20:src/can.c     **** 	for(ch = 0; ch < 15; ch++)
  70               		.loc 1 20 0
  71 0022 80E0      		ldi r24,0
  72               	.LVL1:
  73               	.L7:
  21:src/can.c     **** 	{
  22:src/can.c     **** 		CANPAGE = ch << 4;
  74               		.loc 1 22 0
  75 0024 982F      		mov r25,r24
  76 0026 9295      		swap r25
  77 0028 907F      		andi r25,lo8(-16)
  78 002a 9093 ED00 		sts 237,r25
  23:src/can.c     **** 
  24:src/can.c     **** 		// proveravam da li je uspesno primljen podatak (ako je MOb bio podesen kao prijemnik)
  25:src/can.c     **** 		// PRIJEMNI MOb- ovi uvek ostaju prijemni!
  26:src/can.c     **** 		if( (CANSTMOB >> RXOK) & 0x01)	//receive interrupt
  79               		.loc 1 26 0
  80 002e 9091 EE00 		lds r25,238
  81 0032 95FF      		sbrs r25,5
  82 0034 00C0      		rjmp .L2
  27:src/can.c     **** 		{
  28:src/can.c     **** 			// PRIJEMNI MOb- ovi uvek ostaju prijemni!
  29:src/can.c     **** 			CANCDMOB = (1 << CONMOB1); // podesavam MOb kao receiver
  83               		.loc 1 29 0
  84 0036 80E8      		ldi r24,lo8(-128)
  85               	.LVL2:
  86 0038 8093 EF00 		sts 239,r24
  30:src/can.c     **** 			CANSTMOB &= ~(1 << RXOK); // resetujem flag
  87               		.loc 1 30 0
  88 003c 8091 EE00 		lds r24,238
  89 0040 8F7D      		andi r24,lo8(-33)
  90 0042 8093 EE00 		sts 238,r24
  91               	.LVL3:
  92 0046 80E0      		ldi r24,0
  93 0048 90E0      		ldi r25,0
  94               	.LBB2:
  31:src/can.c     **** 
  32:src/can.c     **** 			for(unsigned char i = 0; i < 8; i++)
  33:src/can.c     **** 				rxBuffer[rxWrIndex].data[i] = CANMSG;
  95               		.loc 1 33 0
  96 004a 5AE0      		ldi r21,lo8(10)
  97               	.LVL4:
  98               	.L3:
  99               		.loc 1 33 0 is_stmt 0 discriminator 3
 100 004c 4091 0000 		lds r20,rxWrIndex
 101 0050 2091 FA00 		lds r18,250
 102 0054 FC01      		movw r30,r24
 103 0056 549F      		mul r21,r20
 104 0058 E00D      		add r30,r0
 105 005a F11D      		adc r31,r1
 106 005c 1124      		clr __zero_reg__
 107 005e E050      		subi r30,lo8(-(rxBuffer))
 108 0060 F040      		sbci r31,hi8(-(rxBuffer))
 109 0062 2083      		st Z,r18
 110               	.LVL5:
 111 0064 0196      		adiw r24,1
 112               	.LVL6:
  32:src/can.c     **** 				rxBuffer[rxWrIndex].data[i] = CANMSG;
 113               		.loc 1 32 0 is_stmt 1 discriminator 3
 114 0066 8830      		cpi r24,8
 115 0068 9105      		cpc r25,__zero_reg__
 116 006a 01F4      		brne .L3
 117               	.LBE2:
  34:src/can.c     **** 			//altUart1Write(rxBuffer[rxWrIndex].data[0]);
  35:src/can.c     **** 
  36:src/can.c     **** 			rxBuffer[rxWrIndex].msgIde = (CANIDT2 >> 5) | (CANIDT1 << 3);
 118               		.loc 1 36 0
 119 006c E091 0000 		lds r30,rxWrIndex
 120 0070 2091 F200 		lds r18,242
 121 0074 8091 F300 		lds r24,243
 122               	.LVL7:
 123 0078 2295      		swap r18
 124 007a 2695      		lsr r18
 125 007c 2770      		andi r18,lo8(7)
 126 007e 48E0      		ldi r20,lo8(8)
 127 0080 849F      		mul r24,r20
 128 0082 C001      		movw r24,r0
 129 0084 1124      		clr __zero_reg__
 130 0086 822B      		or r24,r18
 131 0088 2AE0      		ldi r18,lo8(10)
 132 008a E29F      		mul r30,r18
 133 008c F001      		movw r30,r0
 134 008e 1124      		clr __zero_reg__
 135 0090 E050      		subi r30,lo8(-(rxBuffer))
 136 0092 F040      		sbci r31,hi8(-(rxBuffer))
 137 0094 9187      		std Z+9,r25
 138 0096 8087      		std Z+8,r24
  37:src/can.c     **** 
  38:src/can.c     **** 			if(++rxWrIndex == RX_BUFFER_SIZE)
 139               		.loc 1 38 0
 140 0098 8091 0000 		lds r24,rxWrIndex
 141 009c 8F5F      		subi r24,lo8(-(1))
 142 009e 8093 0000 		sts rxWrIndex,r24
 143 00a2 8233      		cpi r24,lo8(50)
 144 00a4 01F4      		brne .L4
  39:src/can.c     **** 				rxWrIndex = 0;
 145               		.loc 1 39 0
 146 00a6 1092 0000 		sts rxWrIndex,__zero_reg__
 147               	.L4:
  40:src/can.c     **** 
  41:src/can.c     **** 			rxCounter++;
 148               		.loc 1 41 0
 149 00aa 8091 0000 		lds r24,rxCounter
 150 00ae 8F5F      		subi r24,lo8(-(1))
 151 00b0 8093 0000 		sts rxCounter,r24
  42:src/can.c     **** 
  43:src/can.c     **** 			//brPrimljenih1++;
  44:src/can.c     **** 
  45:src/can.c     **** 			break;
 152               		.loc 1 45 0
 153 00b4 00C0      		rjmp .L5
 154               	.LVL8:
 155               	.L2:
  46:src/can.c     **** 		}
  47:src/can.c     **** 
  48:src/can.c     **** 		// proveravam da li je uspesno poslat podatak (ako je MOb bio podesen kao predajnik)
  49:src/can.c     **** 		if( (CANSTMOB >> TXOK) & 0x01)	//transmit interrupt
 156               		.loc 1 49 0
 157 00b6 9091 EE00 		lds r25,238
 158 00ba 96FF      		sbrs r25,6
 159 00bc 00C0      		rjmp .L6
  50:src/can.c     **** 		{
  51:src/can.c     **** 			CANCDMOB = 0; // disable mob
 160               		.loc 1 51 0
 161 00be 1092 EF00 		sts 239,__zero_reg__
  52:src/can.c     **** 			CANSTMOB &= ~(1 << TXOK); // resetujem flag
 162               		.loc 1 52 0
 163 00c2 8091 EE00 		lds r24,238
 164               	.LVL9:
 165 00c6 8F7B      		andi r24,lo8(-65)
 166 00c8 8093 EE00 		sts 238,r24
  53:src/can.c     **** 
  54:src/can.c     **** 			break;
 167               		.loc 1 54 0
 168 00cc 00C0      		rjmp .L5
 169               	.LVL10:
 170               	.L6:
  20:src/can.c     **** 	{
 171               		.loc 1 20 0 discriminator 2
 172 00ce 8F5F      		subi r24,lo8(-(1))
 173               	.LVL11:
 174 00d0 8F30      		cpi r24,lo8(15)
 175 00d2 01F0      		breq .+2
 176 00d4 00C0      		rjmp .L7
 177               	.LVL12:
 178               	.L5:
  55:src/can.c     **** 		}
  56:src/can.c     **** 	}
  57:src/can.c     **** 
  58:src/can.c     **** 	CANPAGE = tempPage;
 179               		.loc 1 58 0
 180 00d6 3093 ED00 		sts 237,r19
 181               	/* epilogue start */
  59:src/can.c     **** 	//CANGIT = CANGIT; // jako retardirano
  60:src/can.c     **** }
 182               		.loc 1 60 0
 183 00da FF91      		pop r31
 184 00dc EF91      		pop r30
 185 00de 9F91      		pop r25
 186 00e0 8F91      		pop r24
 187 00e2 5F91      		pop r21
 188 00e4 4F91      		pop r20
 189 00e6 3F91      		pop r19
 190               	.LVL13:
 191 00e8 2F91      		pop r18
 192 00ea 0F90      		pop r0
 193 00ec 0BBE      		out __RAMPZ__,r0
 194 00ee 0F90      		pop r0
 195 00f0 0FBE      		out __SREG__,r0
 196 00f2 0F90      		pop r0
 197 00f4 1F90      		pop r1
 198 00f6 1895      		reti
 199               		.cfi_endproc
 200               	.LFE0:
 202               	.global	CAN_Init
 204               	CAN_Init:
 205               	.LFB1:
  61:src/can.c     **** 
  62:src/can.c     **** 
  63:src/can.c     **** /*********************************************************************************
  64:src/can.c     **** * Function Name		: CAN_Init
  65:src/can.c     **** * Description       : Funkcija inicijalizuje CAN magistralu podesavanjem
  66:src/can.c     **** 					  odgovarajucih registara kontrolera.
  67:src/can.c     **** 					  BAUD RATE = 250kbps
  68:src/can.c     **** 					  Podrazumeva se da je frekvencija kontrolera 10MHz
  69:src/can.c     **** * Parameters        : None
  70:src/can.c     **** * Return Value      : void
  71:src/can.c     **** *********************************************************************************/
  72:src/can.c     **** void CAN_Init(void)
  73:src/can.c     **** {
 206               		.loc 1 73 0
 207               		.cfi_startproc
 208               	/* prologue: function */
 209               	/* frame size = 0 */
 210               	/* stack size = 0 */
 211               	.L__stack_usage = 0
  74:src/can.c     **** 	unsigned char ch;
  75:src/can.c     **** 	unsigned char data;
  76:src/can.c     **** 
  77:src/can.c     **** 	// Reset the CAN controller
  78:src/can.c     **** 	CANGCON = 0x01;
 212               		.loc 1 78 0
 213 00f8 81E0      		ldi r24,lo8(1)
 214 00fa 8093 D800 		sts 216,r24
 215               	.LVL14:
  79:src/can.c     **** 
  80:src/can.c     **** 	// idem od 0 do 14 MOba i resetujem ih, zato sto posle reseta MObovi imaju nedefinisano stanje
  81:src/can.c     **** 	for(ch = 0; ch < 15; ch++)
 216               		.loc 1 81 0
 217 00fe 80E0      		ldi r24,0
 218               	.LVL15:
 219               	.L13:
  82:src/can.c     **** 	{
  83:src/can.c     **** 		CANPAGE = ch << 4;
 220               		.loc 1 83 0
 221 0100 982F      		mov r25,r24
 222 0102 9295      		swap r25
 223 0104 907F      		andi r25,lo8(-16)
 224 0106 9093 ED00 		sts 237,r25
  84:src/can.c     **** 
  85:src/can.c     **** 		CANSTMOB = 0;
 225               		.loc 1 85 0
 226 010a 1092 EE00 		sts 238,__zero_reg__
  86:src/can.c     **** 		CANCDMOB = 0;
 227               		.loc 1 86 0
 228 010e 1092 EF00 		sts 239,__zero_reg__
  87:src/can.c     **** 
  88:src/can.c     **** 		CANIDT1 = 0;
 229               		.loc 1 88 0
 230 0112 1092 F300 		sts 243,__zero_reg__
  89:src/can.c     **** 		CANIDT2 = 0;
 231               		.loc 1 89 0
 232 0116 1092 F200 		sts 242,__zero_reg__
  90:src/can.c     **** 		CANIDT3 = 0;
 233               		.loc 1 90 0
 234 011a 1092 F100 		sts 241,__zero_reg__
  91:src/can.c     **** 		CANIDT4 = 0;
 235               		.loc 1 91 0
 236 011e 1092 F000 		sts 240,__zero_reg__
  92:src/can.c     **** 		CANIDM1 = 0;
 237               		.loc 1 92 0
 238 0122 1092 F700 		sts 247,__zero_reg__
  93:src/can.c     **** 		CANIDM2 = 0;
 239               		.loc 1 93 0
 240 0126 1092 F600 		sts 246,__zero_reg__
  94:src/can.c     **** 		CANIDM3 = 0;
 241               		.loc 1 94 0
 242 012a 1092 F500 		sts 245,__zero_reg__
  95:src/can.c     **** 		CANIDM4 = 0;
 243               		.loc 1 95 0
 244 012e 1092 F400 		sts 244,__zero_reg__
 245               	.LVL16:
 246 0132 98E0      		ldi r25,lo8(8)
 247               	.LVL17:
 248               	.L12:
  96:src/can.c     **** 
  97:src/can.c     **** 		// CANMSG je organizovan kao 8- bajtni FIFO red
  98:src/can.c     **** 		// koristi se auto-increment pa ce proci kroz svih 8 bajtova poruke-> organizovan kao FIFO
  99:src/can.c     **** 		for (data = 0; data < 8; data++)
 100:src/can.c     **** 			CANMSG = 0;
 249               		.loc 1 100 0 discriminator 3
 250 0134 1092 FA00 		sts 250,__zero_reg__
 251               	.LVL18:
 252 0138 9150      		subi r25,lo8(-(-1))
 253               	.LVL19:
  99:src/can.c     **** 			CANMSG = 0;
 254               		.loc 1 99 0 discriminator 3
 255 013a 01F4      		brne .L12
  81:src/can.c     **** 	{
 256               		.loc 1 81 0 discriminator 2
 257 013c 8F5F      		subi r24,lo8(-(1))
 258               	.LVL20:
 259 013e 8F30      		cpi r24,lo8(15)
 260 0140 01F4      		brne .L13
 101:src/can.c     **** 	}
 102:src/can.c     **** 
 103:src/can.c     **** 
 104:src/can.c     **** 	// Enable the CAN controller
 105:src/can.c     **** 	CANGCON = 0x02;
 261               		.loc 1 105 0
 262 0142 82E0      		ldi r24,lo8(2)
 263               	.LVL21:
 264 0144 8093 D800 		sts 216,r24
 106:src/can.c     **** 
 107:src/can.c     **** 	/************ BIT TAJMING PODESAVANJA -> BAUD RATE = 100kbps  **********************************/
 108:src/can.c     **** 
 109:src/can.c     **** 	//CANBT1 = 0x08; // Fcan = 2Mhz-> Tq = 0.5us
 110:src/can.c     **** 	CANBT1 = 0x01;
 265               		.loc 1 110 0
 266 0148 81E0      		ldi r24,lo8(1)
 267 014a 8093 E200 		sts 226,r24
 111:src/can.c     **** 	CANBT2 = (1 << PRS2) | (1 << PRS0); // Propagation Time Segment-> 6xTq-> BILO 5
 268               		.loc 1 111 0
 269 014e 8AE0      		ldi r24,lo8(10)
 270 0150 8093 E300 		sts 227,r24
 112:src/can.c     **** 	CANBT3 = (1 << PHS22) | (1 << PHS21) /*| (1 << PHS20) */| (1 << PHS10) | (1 << PHS11) | (1 << PHS1
 271               		.loc 1 112 0
 272 0154 8EE6      		ldi r24,lo8(110)
 273 0156 8093 E400 		sts 228,r24
 113:src/can.c     **** 
 114:src/can.c     **** 	/// Sjw je podesen na 1... 1 + 5 + 6 + 8 = 20
 115:src/can.c     **** 	/************ BIT TAJMING PODESAVANJA -> BAUD RATE = 100kbps  **********************************/
 116:src/can.c     **** 
 117:src/can.c     **** 	CANTCON = 0; // preskaler za CAN timer-> ne koristimo ga pa ova vrednost nije vazna
 274               		.loc 1 117 0
 275 015a 1092 E500 		sts 229,__zero_reg__
 118:src/can.c     **** 
 119:src/can.c     **** 	// ukljucujem interrupte- ENIT-> Enable All Interrupts
 120:src/can.c     **** 	// ENRX-> Enable RX interrupt
 121:src/can.c     **** 	// ENTX-> Enable TX interrupt
 122:src/can.c     **** 	CANGIE = (1 << ENIT) | (1 << ENRX) | (1 << ENTX);
 276               		.loc 1 122 0
 277 015e 80EB      		ldi r24,lo8(-80)
 278 0160 8093 DB00 		sts 219,r24
 123:src/can.c     **** 	// interrupti svih MOb- ova su ukljuceni
 124:src/can.c     **** 	CANIE1 = 0xFF >> 1; // glupo govno trazi da MSB mora biti nula prilikom upisivanja u registar
 279               		.loc 1 124 0
 280 0164 8FE7      		ldi r24,lo8(127)
 281 0166 8093 DF00 		sts 223,r24
 125:src/can.c     **** 	CANIE2 = 0xFF;
 282               		.loc 1 125 0
 283 016a 8FEF      		ldi r24,lo8(-1)
 284 016c 8093 DE00 		sts 222,r24
 285 0170 0895      		ret
 286               		.cfi_endproc
 287               	.LFE1:
 289               	.global	CAN_InitRxMob
 291               	CAN_InitRxMob:
 292               	.LFB2:
 126:src/can.c     **** 
 127:src/can.c     **** 	//sei();
 128:src/can.c     **** }
 129:src/can.c     **** 
 130:src/can.c     **** 
 131:src/can.c     **** /*********************************************************************************
 132:src/can.c     **** * Function Name		: CAN_InitRxMob
 133:src/can.c     **** * Description       : Funkcija inicijalizuje prvi slobodni MOb kao prijemnik.
 134:src/can.c     **** 					  Taj prijemni MOb ce primati samo poruke sa identifikatorom
 135:src/can.c     **** 					  ide. U slucaju neuspesne inicijalizacije MOb- a vraca 0
 136:src/can.c     **** * Parameters        : unsigned int ide
 137:src/can.c     **** * Return Value      : char info da li je inicijalizacija uspela
 138:src/can.c     **** *********************************************************************************/
 139:src/can.c     **** char CAN_InitRxMob(unsigned int ide)
 140:src/can.c     **** {
 293               		.loc 1 140 0
 294               		.cfi_startproc
 295               	.LVL22:
 296               	/* prologue: function */
 297               	/* frame size = 0 */
 298               	/* stack size = 0 */
 299               	.L__stack_usage = 0
 141:src/can.c     **** 	unsigned char ch;
 142:src/can.c     **** 	unsigned char tempPage = CANPAGE;
 300               		.loc 1 142 0
 301 0172 4091 ED00 		lds r20,237
 302               	.LVL23:
 303               	.L17:
 143:src/can.c     **** 
 144:src/can.c     **** 	while(((CANGSTA >> TXBSY) & 0x01) || ((CANGSTA >> RXBSY) & 0x01));
 304               		.loc 1 144 0 discriminator 3
 305 0176 2091 D900 		lds r18,217
 306 017a 24FD      		sbrc r18,4
 307 017c 00C0      		rjmp .L17
 308               		.loc 1 144 0 is_stmt 0 discriminator 2
 309 017e 2091 D900 		lds r18,217
 310 0182 23FD      		sbrc r18,3
 311 0184 00C0      		rjmp .L17
 312 0186 20E0      		ldi r18,0
 313               	.L20:
 314               	.LVL24:
 145:src/can.c     **** 
 146:src/can.c     **** 	// prolazim redom kroz MOb- ove, cim naidjem na slobodan MOb
 147:src/can.c     **** 	// uzimam ga
 148:src/can.c     **** 	for(ch = 0; ch < 15; ch++)
 149:src/can.c     **** 	{
 150:src/can.c     **** 		CANPAGE = ch << 4;
 315               		.loc 1 150 0 is_stmt 1
 316 0188 322F      		mov r19,r18
 317 018a 3295      		swap r19
 318 018c 307F      		andi r19,lo8(-16)
 319 018e 3093 ED00 		sts 237,r19
 151:src/can.c     **** 
 152:src/can.c     **** 		// ako je MOb vec zauzet nastavi dalje
 153:src/can.c     **** 		if((CANCDMOB >> 6))
 320               		.loc 1 153 0
 321 0192 3091 EF00 		lds r19,239
 322 0196 3295      		swap r19
 323 0198 3695      		lsr r19
 324 019a 3695      		lsr r19
 325 019c 3370      		andi r19,lo8(3)
 326 019e 01F0      		breq .L19
 148:src/can.c     **** 	{
 327               		.loc 1 148 0
 328 01a0 2F5F      		subi r18,lo8(-(1))
 329               	.LVL25:
 330 01a2 2F30      		cpi r18,lo8(15)
 331 01a4 01F4      		brne .L20
 154:src/can.c     **** 			continue;
 155:src/can.c     **** 
 156:src/can.c     **** 		//uvek primam 8 bajtova
 157:src/can.c     **** 		CANCDMOB = (1 << DLC0) | (1 << DLC1) | (1 << DLC2) | (1 << DLC3);
 158:src/can.c     **** 
 159:src/can.c     **** 		// podesavam identifikator
 160:src/can.c     **** 		CANIDT1 = (0x00FF & ide) >> 3;
 161:src/can.c     **** 		CANIDT2 = (ide & 0x00FF) << 5;
 162:src/can.c     **** 
 163:src/can.c     **** 		// podesavam masku- gledam sve bitove
 164:src/can.c     **** 		CANIDM2 = 0x07 << 5;
 165:src/can.c     **** 		CANIDM1 = 0xFF;
 166:src/can.c     **** 
 167:src/can.c     **** 		// podesavam MOb kao receiver
 168:src/can.c     **** 		CANCDMOB |= (1 << CONMOB1);
 169:src/can.c     **** 		sei();
 170:src/can.c     **** 		CANPAGE = tempPage;
 171:src/can.c     **** 
 172:src/can.c     **** 		return 1;
 173:src/can.c     **** 	}
 174:src/can.c     **** 
 175:src/can.c     **** 	CANPAGE = tempPage;
 332               		.loc 1 175 0
 333 01a6 4093 ED00 		sts 237,r20
 176:src/can.c     **** 
 177:src/can.c     **** 	return 0;
 334               		.loc 1 177 0
 335 01aa 80E0      		ldi r24,0
 336               	.LVL26:
 178:src/can.c     **** }
 337               		.loc 1 178 0
 338 01ac 0895      		ret
 339               	.LVL27:
 340               	.L19:
 157:src/can.c     **** 
 341               		.loc 1 157 0
 342 01ae 2FE0      		ldi r18,lo8(15)
 343               	.LVL28:
 344 01b0 2093 EF00 		sts 239,r18
 160:src/can.c     **** 		CANIDT2 = (ide & 0x00FF) << 5;
 345               		.loc 1 160 0
 346 01b4 9C01      		movw r18,r24
 347 01b6 3327      		clr r19
 348 01b8 93E0      		ldi r25,3
 349               		1:
 350 01ba 3695      		lsr r19
 351 01bc 2795      		ror r18
 352 01be 9A95      		dec r25
 353 01c0 01F4      		brne 1b
 354 01c2 2093 F300 		sts 243,r18
 161:src/can.c     **** 
 355               		.loc 1 161 0
 356 01c6 8295      		swap r24
 357               	.LVL29:
 358 01c8 880F      		lsl r24
 359 01ca 807E      		andi r24,lo8(-32)
 360 01cc 8093 F200 		sts 242,r24
 164:src/can.c     **** 		CANIDM1 = 0xFF;
 361               		.loc 1 164 0
 362 01d0 80EE      		ldi r24,lo8(-32)
 363 01d2 8093 F600 		sts 246,r24
 165:src/can.c     **** 
 364               		.loc 1 165 0
 365 01d6 8FEF      		ldi r24,lo8(-1)
 366 01d8 8093 F700 		sts 247,r24
 168:src/can.c     **** 		sei();
 367               		.loc 1 168 0
 368 01dc 8091 EF00 		lds r24,239
 369 01e0 8068      		ori r24,lo8(-128)
 370 01e2 8093 EF00 		sts 239,r24
 169:src/can.c     **** 		CANPAGE = tempPage;
 371               		.loc 1 169 0
 372               	/* #APP */
 373               	 ;  169 "src/can.c" 1
 374 01e6 7894      		sei
 375               	 ;  0 "" 2
 170:src/can.c     **** 
 376               		.loc 1 170 0
 377               	/* #NOAPP */
 378 01e8 4093 ED00 		sts 237,r20
 172:src/can.c     **** 	}
 379               		.loc 1 172 0
 380 01ec 81E0      		ldi r24,lo8(1)
 381 01ee 0895      		ret
 382               		.cfi_endproc
 383               	.LFE2:
 385               	.global	CAN_checkRX
 387               	CAN_checkRX:
 388               	.LFB3:
 179:src/can.c     **** 
 180:src/can.c     **** 
 181:src/can.c     **** /*********************************************************************************
 182:src/can.c     **** * Function Name		: CAN_checkRx
 183:src/can.c     **** * Description       : Funkcija proverava da li ima primljenih podataka.
 184:src/can.c     **** 					  Ako ima vraca 1, u suprotnom vraca 0
 185:src/can.c     **** * Parameters        : None
 186:src/can.c     **** * Return Value      : char info da li ima primljenih podataka
 187:src/can.c     **** *********************************************************************************/
 188:src/can.c     **** char CAN_checkRX(void)
 189:src/can.c     **** {
 389               		.loc 1 189 0
 390               		.cfi_startproc
 391               	/* prologue: function */
 392               	/* frame size = 0 */
 393               	/* stack size = 0 */
 394               	.L__stack_usage = 0
 190:src/can.c     **** 	if(rxCounter)
 395               		.loc 1 190 0
 396 01f0 9091 0000 		lds r25,rxCounter
 397 01f4 81E0      		ldi r24,lo8(1)
 398 01f6 9111      		cpse r25,__zero_reg__
 399 01f8 00C0      		rjmp .L28
 400 01fa 80E0      		ldi r24,0
 401               	.L28:
 191:src/can.c     **** 		return 1;
 192:src/can.c     **** 
 193:src/can.c     **** 	return 0;
 194:src/can.c     **** }
 402               		.loc 1 194 0
 403 01fc 0895      		ret
 404               		.cfi_endproc
 405               	.LFE3:
 407               	.global	CAN_read
 409               	CAN_read:
 410               	.LFB4:
 195:src/can.c     **** 
 196:src/can.c     **** 
 197:src/can.c     **** /*********************************************************************************
 198:src/can.c     **** * Function Name		: CAN_read
 199:src/can.c     **** * Description       : Funkcija cita 8- bajtni niz karaktera iz prijemnog bafera CAN
 200:src/can.c     **** 					  magistrale.
 201:src/can.c     **** 				      U slucaju da nema primljenih podataka funkcija ceka na
 202:src/can.c     **** 					  na podatak.
 203:src/can.c     **** * Parameters        : canMsg *rxData
 204:src/can.c     **** * Return Value      : void
 205:src/can.c     **** *********************************************************************************/
 206:src/can.c     **** void CAN_read(canMsg *rxData)
 207:src/can.c     **** {
 411               		.loc 1 207 0
 412               		.cfi_startproc
 413               	/* prologue: function */
 414               	/* frame size = 0 */
 415               	/* stack size = 0 */
 416               	.L__stack_usage = 0
 417               	.LVL30:
 418               	.L30:
 208:src/can.c     **** 	// sve dok ne stigne neki podatak ostajem u funkciji
 209:src/can.c     **** 
 210:src/can.c     **** 	// kako je task realizovan ovo je nepotrebno ali neka stoji
 211:src/can.c     **** 	while(rxCounter == 0);
 419               		.loc 1 211 0 discriminator 1
 420 01fe 2091 0000 		lds r18,rxCounter
 421 0202 2223      		tst r18
 422 0204 01F0      		breq .L30
 212:src/can.c     **** 	cli();
 423               		.loc 1 212 0
 424               	/* #APP */
 425               	 ;  212 "src/can.c" 1
 426 0206 F894      		cli
 427               	 ;  0 "" 2
 428               	.LVL31:
 429               	/* #NOAPP */
 430 0208 DC01      		movw r26,r24
 431 020a 20E0      		ldi r18,0
 432 020c 30E0      		ldi r19,0
 433               	.LBB3:
 213:src/can.c     **** 	//nema potrebe da iskljucujemo multitasking zato sto nema opasnosti da cu primiti pogresan podatak
 214:src/can.c     **** 
 215:src/can.c     **** 	// upisujem osam bajtova u prosledjeni bafer( argument funkcije, prenos po adresi)
 216:src/can.c     **** 	for(unsigned char i = 0; i < 8; i++)
 217:src/can.c     **** 		rxData->data[i] = rxBuffer[rxRdIndex].data[i];
 434               		.loc 1 217 0
 435 020e 5AE0      		ldi r21,lo8(10)
 436               	.LVL32:
 437               	.L31:
 438               		.loc 1 217 0 is_stmt 0 discriminator 3
 439 0210 4091 0000 		lds r20,rxRdIndex
 440 0214 F901      		movw r30,r18
 441 0216 549F      		mul r21,r20
 442 0218 E00D      		add r30,r0
 443 021a F11D      		adc r31,r1
 444 021c 1124      		clr __zero_reg__
 445 021e E050      		subi r30,lo8(-(rxBuffer))
 446 0220 F040      		sbci r31,hi8(-(rxBuffer))
 447 0222 4081      		ld r20,Z
 448 0224 4D93      		st X+,r20
 449               	.LVL33:
 450 0226 2F5F      		subi r18,-1
 451 0228 3F4F      		sbci r19,-1
 452               	.LVL34:
 216:src/can.c     **** 		rxData->data[i] = rxBuffer[rxRdIndex].data[i];
 453               		.loc 1 216 0 is_stmt 1 discriminator 3
 454 022a 2830      		cpi r18,8
 455 022c 3105      		cpc r19,__zero_reg__
 456 022e 01F4      		brne .L31
 457               	.LBE3:
 218:src/can.c     **** 
 219:src/can.c     **** 	rxData->msgIde = rxBuffer[rxRdIndex].msgIde;
 458               		.loc 1 219 0
 459 0230 E091 0000 		lds r30,rxRdIndex
 460 0234 2AE0      		ldi r18,lo8(10)
 461               	.LVL35:
 462 0236 E29F      		mul r30,r18
 463 0238 F001      		movw r30,r0
 464 023a 1124      		clr __zero_reg__
 465 023c E050      		subi r30,lo8(-(rxBuffer))
 466 023e F040      		sbci r31,hi8(-(rxBuffer))
 467 0240 2085      		ldd r18,Z+8
 468 0242 3185      		ldd r19,Z+9
 469 0244 FC01      		movw r30,r24
 470 0246 3187      		std Z+9,r19
 471 0248 2087      		std Z+8,r18
 220:src/can.c     **** 
 221:src/can.c     **** 	if(++rxRdIndex == RX_BUFFER_SIZE)
 472               		.loc 1 221 0
 473 024a 8091 0000 		lds r24,rxRdIndex
 474               	.LVL36:
 475 024e 8F5F      		subi r24,lo8(-(1))
 476 0250 8093 0000 		sts rxRdIndex,r24
 477 0254 8233      		cpi r24,lo8(50)
 478 0256 01F4      		brne .L32
 222:src/can.c     **** 		rxRdIndex = 0;
 479               		.loc 1 222 0
 480 0258 1092 0000 		sts rxRdIndex,__zero_reg__
 481               	.L32:
 223:src/can.c     **** 
 224:src/can.c     **** 
 225:src/can.c     **** 	rxCounter--;
 482               		.loc 1 225 0
 483 025c 8091 0000 		lds r24,rxCounter
 484 0260 8150      		subi r24,lo8(-(-1))
 485 0262 8093 0000 		sts rxCounter,r24
 226:src/can.c     **** 	sei();
 486               		.loc 1 226 0
 487               	/* #APP */
 488               	 ;  226 "src/can.c" 1
 489 0266 7894      		sei
 490               	 ;  0 "" 2
 491               	/* #NOAPP */
 492 0268 0895      		ret
 493               		.cfi_endproc
 494               	.LFE4:
 496               	.global	CAN_write
 498               	CAN_write:
 499               	.LFB5:
 227:src/can.c     **** }
 228:src/can.c     **** 
 229:src/can.c     **** 
 230:src/can.c     **** /*********************************************************************************
 231:src/can.c     **** * Function Name		: CAN_write
 232:src/can.c     **** * Description       : Funkcija upisuje 8 bajtova podataka u predajni bafer CAN
 233:src/can.c     **** 					  magistrale. Pored tih podataka, salje se i njen
 234:src/can.c     **** 					  identifikator messIdentificator.
 235:src/can.c     **** * Parameters        : canMgs txData
 236:src/can.c     **** * Return Value      : void
 237:src/can.c     **** *********************************************************************************/
 238:src/can.c     **** char CAN_write(canMsg txData)
 239:src/can.c     **** {
 500               		.loc 1 239 0
 501               		.cfi_startproc
 502 026a 0F93      		push r16
 503               	.LCFI10:
 504               		.cfi_def_cfa_offset 3
 505               		.cfi_offset 16, -2
 506 026c 1F93      		push r17
 507               	.LCFI11:
 508               		.cfi_def_cfa_offset 4
 509               		.cfi_offset 17, -3
 510 026e CF93      		push r28
 511               	.LCFI12:
 512               		.cfi_def_cfa_offset 5
 513               		.cfi_offset 28, -4
 514 0270 DF93      		push r29
 515               	.LCFI13:
 516               		.cfi_def_cfa_offset 6
 517               		.cfi_offset 29, -5
 518 0272 CDB7      		in r28,__SP_L__
 519 0274 DEB7      		in r29,__SP_H__
 520               	.LCFI14:
 521               		.cfi_def_cfa_register 28
 522 0276 2A97      		sbiw r28,10
 523               	.LCFI15:
 524               		.cfi_def_cfa_offset 16
 525 0278 0FB6      		in __tmp_reg__,__SREG__
 526 027a F894      		cli
 527 027c DEBF      		out __SP_H__,r29
 528 027e 0FBE      		out __SREG__,__tmp_reg__
 529 0280 CDBF      		out __SP_L__,r28
 530               	/* prologue: function */
 531               	/* frame size = 10 */
 532               	/* stack size = 14 */
 533               	.L__stack_usage = 14
 534 0282 0983      		std Y+1,r16
 535 0284 1A83      		std Y+2,r17
 536 0286 2B83      		std Y+3,r18
 537 0288 3C83      		std Y+4,r19
 538 028a 4D83      		std Y+5,r20
 539 028c 5E83      		std Y+6,r21
 540 028e 6F83      		std Y+7,r22
 541 0290 7887      		std Y+8,r23
 542 0292 8987      		std Y+9,r24
 543 0294 9A87      		std Y+10,r25
 544 0296 8985      		ldd r24,Y+9
 545 0298 9A85      		ldd r25,Y+10
 546               	.LVL37:
 547               	.L37:
 240:src/can.c     **** 	// Cekam sve dok je magistrala zauzeta-> da li je neophodno?
 241:src/can.c     **** 	while(((CANGSTA >> TXBSY) & 0x01) || ((CANGSTA >> RXBSY) & 0x01));
 548               		.loc 1 241 0 discriminator 3
 549 029a 2091 D900 		lds r18,217
 550 029e 24FD      		sbrc r18,4
 551 02a0 00C0      		rjmp .L37
 552               		.loc 1 241 0 is_stmt 0 discriminator 2
 553 02a2 2091 D900 		lds r18,217
 554 02a6 23FD      		sbrc r18,3
 555 02a8 00C0      		rjmp .L37
 242:src/can.c     **** 	//taskENTER_CRITICAL();
 243:src/can.c     **** 	unsigned char ch;
 244:src/can.c     **** 	unsigned char tempPage = CANPAGE;
 556               		.loc 1 244 0 is_stmt 1
 557 02aa 4091 ED00 		lds r20,237
 558               	.LVL38:
 245:src/can.c     **** 
 246:src/can.c     **** 	// ovo je mozda nepotrebno, razmisliti
 247:src/can.c     **** 	//taskENTER_CRITICAL();
 248:src/can.c     **** 
 249:src/can.c     **** 	// trazim slobodan MOb
 250:src/can.c     **** 	for(ch = 0; ch < 15; ch++)
 559               		.loc 1 250 0
 560 02ae 20E0      		ldi r18,0
 561               	.LVL39:
 562               	.L40:
 251:src/can.c     **** 	{
 252:src/can.c     **** 		CANPAGE = ch << 4;
 563               		.loc 1 252 0
 564 02b0 322F      		mov r19,r18
 565 02b2 3295      		swap r19
 566 02b4 307F      		andi r19,lo8(-16)
 567 02b6 3093 ED00 		sts 237,r19
 253:src/can.c     **** 
 254:src/can.c     **** 		if(!(CANCDMOB >> 6))
 568               		.loc 1 254 0
 569 02ba 3091 EF00 		lds r19,239
 570 02be 3295      		swap r19
 571 02c0 3695      		lsr r19
 572 02c2 3695      		lsr r19
 573 02c4 3370      		andi r19,lo8(3)
 574 02c6 01F0      		breq .L39
 250:src/can.c     **** 	{
 575               		.loc 1 250 0 discriminator 2
 576 02c8 2F5F      		subi r18,lo8(-(1))
 577               	.LVL40:
 578 02ca 2F30      		cpi r18,lo8(15)
 579 02cc 01F4      		brne .L40
 255:src/can.c     **** 			break;
 256:src/can.c     **** 	}
 257:src/can.c     **** 
 258:src/can.c     **** 	// nema slobodnih MOb- ova
 259:src/can.c     **** 	if(ch == 15)
 260:src/can.c     **** 	{
 261:src/can.c     **** 		//taskEXIT_CRITICAL();
 262:src/can.c     **** 
 263:src/can.c     **** 		return 0;
 580               		.loc 1 263 0
 581 02ce 80E0      		ldi r24,0
 582               	.LVL41:
 583 02d0 00C0      		rjmp .L47
 584               	.LVL42:
 585               	.L39:
 264:src/can.c     **** 	}
 265:src/can.c     **** 
 266:src/can.c     **** 	//ova dva registra sadrze identifikator poruke koja ce se slati! efektivno to je adresa cvora koji
 267:src/can.c     **** 	CANIDT2 = (txData.msgIde & 0x0F) << 5;
 586               		.loc 1 267 0
 587 02d2 282F      		mov r18,r24
 588               	.LVL43:
 589 02d4 2295      		swap r18
 590 02d6 220F      		lsl r18
 591 02d8 207E      		andi r18,lo8(-32)
 592 02da 2093 F200 		sts 242,r18
 268:src/can.c     **** 	CANIDT1 = (txData.msgIde) >> 3;
 593               		.loc 1 268 0
 594 02de 23E0      		ldi r18,3
 595               		1:
 596 02e0 9695      		lsr r25
 597 02e2 8795      		ror r24
 598 02e4 2A95      		dec r18
 599 02e6 01F4      		brne 1b
 600               	.LVL44:
 601 02e8 8093 F300 		sts 243,r24
 269:src/can.c     **** 
 270:src/can.c     **** 	// DLC = 8
 271:src/can.c     **** 	CANCDMOB = 8;
 602               		.loc 1 271 0
 603 02ec 88E0      		ldi r24,lo8(8)
 604 02ee 8093 EF00 		sts 239,r24
 605               	.LVL45:
 606 02f2 FE01      		movw r30,r28
 607 02f4 3196      		adiw r30,1
 608 02f6 CE01      		movw r24,r28
 609 02f8 0996      		adiw r24,9
 610               	.LVL46:
 611               	.L42:
 612               	.LBB4:
 272:src/can.c     **** 
 273:src/can.c     **** 	// upisujem 8 bajtova koje ce se slati u predajni bafer
 274:src/can.c     **** 	for(unsigned char i = 0; i < 8; i++)
 275:src/can.c     **** 		CANMSG = txData.data[i];
 613               		.loc 1 275 0 discriminator 3
 614 02fa 2191      		ld r18,Z+
 615 02fc 2093 FA00 		sts 250,r18
 274:src/can.c     **** 		CANMSG = txData.data[i];
 616               		.loc 1 274 0 discriminator 3
 617 0300 8E17      		cp r24,r30
 618 0302 9F07      		cpc r25,r31
 619 0304 01F4      		brne .L42
 620               	.LBE4:
 276:src/can.c     **** 
 277:src/can.c     **** 	// podesavam ga kao predajnik
 278:src/can.c     **** 	CANCDMOB |= (1 << CONMOB0);
 621               		.loc 1 278 0
 622 0306 8091 EF00 		lds r24,239
 623 030a 8064      		ori r24,lo8(64)
 624 030c 8093 EF00 		sts 239,r24
 279:src/can.c     **** 
 280:src/can.c     **** 	CANPAGE = tempPage;
 625               		.loc 1 280 0
 626 0310 4093 ED00 		sts 237,r20
 281:src/can.c     **** 
 282:src/can.c     **** 	//taskEXIT_CRITICAL();
 283:src/can.c     **** 
 284:src/can.c     **** 	return 1;
 627               		.loc 1 284 0
 628 0314 81E0      		ldi r24,lo8(1)
 629               	.L47:
 630               	/* epilogue start */
 285:src/can.c     **** }...
 631               		.loc 1 285 0
 632 0316 2A96      		adiw r28,10
 633 0318 0FB6      		in __tmp_reg__,__SREG__
 634 031a F894      		cli
 635 031c DEBF      		out __SP_H__,r29
 636 031e 0FBE      		out __SREG__,__tmp_reg__
 637 0320 CDBF      		out __SP_L__,r28
 638 0322 DF91      		pop r29
 639 0324 CF91      		pop r28
 640 0326 1F91      		pop r17
 641 0328 0F91      		pop r16
 642 032a 0895      		ret
 643               		.cfi_endproc
 644               	.LFE5:
 646               		.local	rxCounter
 647               		.comm	rxCounter,1,1
 648               		.local	rxWrIndex
 649               		.comm	rxWrIndex,1,1
 650               		.local	rxRdIndex
 651               		.comm	rxRdIndex,1,1
 652               		.local	rxBuffer
 653               		.comm	rxBuffer,500,1
 654               	.Letext0:
 655               		.file 2 "src/can.h"
 656               		.file 3 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 can.c
     /tmp/ccbosQPA.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccbosQPA.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccbosQPA.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccbosQPA.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccbosQPA.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccbosQPA.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccbosQPA.s:13     .text:0000000000000000 __vector_18
     /tmp/ccbosQPA.s:647    .bss:0000000000000001 rxWrIndex
     /tmp/ccbosQPA.s:651    .bss:0000000000000003 rxBuffer
                             .bss:0000000000000000 rxCounter
     /tmp/ccbosQPA.s:204    .text:00000000000000f8 CAN_Init
     /tmp/ccbosQPA.s:291    .text:0000000000000172 CAN_InitRxMob
     /tmp/ccbosQPA.s:387    .text:00000000000001f0 CAN_checkRX
     /tmp/ccbosQPA.s:409    .text:00000000000001fe CAN_read
     /tmp/ccbosQPA.s:649    .bss:0000000000000002 rxRdIndex
     /tmp/ccbosQPA.s:498    .text:000000000000026a CAN_write

UNDEFINED SYMBOLS
__do_clear_bss
