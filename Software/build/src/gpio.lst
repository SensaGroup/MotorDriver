   1               		.file	"gpio.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               	.global	gpio_register_pin
  13               	gpio_register_pin:
  14               	.LVL0:
  15               	.LFB11:
  16               		.file 1 "src/gpio.c"
   1:src/gpio.c    **** #include "gpio.h"
   2:src/gpio.c    **** 
   3:src/gpio.c    **** struct gpio_input {
   4:src/gpio.c    ****     uint8_t          pin;
   5:src/gpio.c    ****     bool             pulled_up;
   6:src/gpio.c    ****     uint8_t          values[GPIO_DEBOUNCE_COUNT];
   7:src/gpio.c    ****     uint8_t          previous_state;
   8:src/gpio.c    **** 
   9:src/gpio.c    ****     struct list_head list;
  10:src/gpio.c    **** };
  11:src/gpio.c    **** 
  12:src/gpio.c    **** LIST_HEAD(gpio_inputs);
  13:src/gpio.c    **** 
  14:src/gpio.c    **** /*
  15:src/gpio.c    ****  * 	Function:    uint8_t gpio_register_pin(uint8_t pin, uint8_t direction, bool pulled_up)
  16:src/gpio.c    ****  * 	Description: register the pin
  17:src/gpio.c    ****  */
  18:src/gpio.c    **** uint8_t gpio_register_pin(uint8_t pin, uint8_t direction, bool pulled_up) {
  17               		.loc 1 18 75 view -0
  18               		.cfi_startproc
  19               		.loc 1 18 75 is_stmt 0 view .LVU1
  20 0000 0F93      		push r16
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 16, -2
  24 0002 1F93      		push r17
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 17, -3
  28 0004 CF93      		push r28
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 28, -4
  32 0006 DF93      		push r29
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 29, -5
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 4 */
  39               	.L__stack_usage = 4
  40 0008 182F      		mov r17,r24
  41 000a 042F      		mov r16,r20
  19:src/gpio.c    ****     struct gpio_input* input;
  42               		.loc 1 19 5 is_stmt 1 view .LVU2
  20:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
  43               		.loc 1 20 5 view .LVU3
  44               	.LBB10:
  45               		.loc 1 20 5 view .LVU4
  46               	.LVL1:
  47               		.loc 1 20 5 view .LVU5
  48 000c E091 0000 		lds r30,gpio_inputs+2
  49 0010 F091 0000 		lds r31,gpio_inputs+2+1
  50               	.LVL2:
  51               	.L11:
  52               		.loc 1 20 5 is_stmt 0 view .LVU6
  53               	.LBE10:
  54               	.LBB11:
  55               		.loc 1 20 5 discriminator 2 view .LVU7
  56 0014 3D97      		sbiw r30,13
  57               	.LVL3:
  58               		.loc 1 20 5 discriminator 2 view .LVU8
  59               	.LBE11:
  60 0016 EF01      		movw r28,r30
  61 0018 2D96      		adiw r28,13
  62 001a 80E0      		ldi r24,hi8(gpio_inputs)
  63 001c C030      		cpi r28,lo8(gpio_inputs)
  64 001e D807      		cpc r29,r24
  65 0020 01F4      		brne .L5
  21:src/gpio.c    ****     {
  22:src/gpio.c    ****         if(input->pin == pin)
  23:src/gpio.c    ****             return 1;
  24:src/gpio.c    ****     }
  25:src/gpio.c    **** 
  26:src/gpio.c    **** 	uint8_t port	= 1 + pin / 8;
  66               		.loc 1 26 2 is_stmt 1 view .LVU9
  67               	.LVL4:
  27:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  68               		.loc 1 27 2 view .LVU10
  28:src/gpio.c    **** 	if(direction == GPIO_DIRECTION_OUTPUT)
  69               		.loc 1 28 2 view .LVU11
  26:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  70               		.loc 1 26 19 is_stmt 0 view .LVU12
  71 0022 E12F      		mov r30,r17
  72               	.LVL5:
  26:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  73               		.loc 1 26 19 view .LVU13
  74 0024 E695      		lsr r30
  75 0026 E695      		lsr r30
  76 0028 E695      		lsr r30
  26:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  77               		.loc 1 26 10 view .LVU14
  78 002a EF5F      		subi r30,lo8(-(1))
  79               	.LVL6:
  26:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  80               		.loc 1 26 10 view .LVU15
  81 002c E150      		subi r30,1
  82 002e FF0B      		sbc r31,r31
  83               	.LVL7:
  26:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  84               		.loc 1 26 10 view .LVU16
  85 0030 CF01      		movw r24,r30
  86 0032 880F      		lsl r24
  87 0034 991F      		rol r25
  88 0036 E80F      		add r30,r24
  89 0038 F91F      		adc r31,r25
  27:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  90               		.loc 1 27 10 view .LVU17
  91 003a 212F      		mov r18,r17
  92 003c 2770      		andi r18,lo8(7)
  93               	.LVL8:
  27:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
  94               		.loc 1 27 10 view .LVU18
  95 003e 81E0      		ldi r24,lo8(1)
  96 0040 90E0      		ldi r25,0
  97 0042 00C0      		rjmp 2f
  98               		1:
  99 0044 880F      		lsl r24
 100               		2:
 101 0046 2A95      		dec r18
 102 0048 02F4      		brpl 1b
 103 004a 282F      		mov r18,r24
 104               	.LVL9:
  27:src/gpio.c    **** 	uint8_t pin_reg = pin % 8;
 105               		.loc 1 27 10 view .LVU19
 106 004c 2095      		com r18
 107               		.loc 1 28 4 view .LVU20
 108 004e 6130      		cpi r22,lo8(1)
 109 0050 01F4      		brne .L6
  29:src/gpio.c    **** 	{
  30:src/gpio.c    **** 		*(volatile uint8_t*)(0x21 + 3 *  (port - 1)) |= (1 << pin_reg);
 110               		.loc 1 30 3 is_stmt 1 view .LVU21
 111               		.loc 1 30 48 is_stmt 0 view .LVU22
 112 0052 91A1      		ldd r25,Z+33
 113 0054 892B      		or r24,r25
 114 0056 81A3      		std Z+33,r24
 115               	.LVL10:
  31:src/gpio.c    **** 		*(volatile uint8_t*)(0x22 + 3 *  (port - 1)) &= ~(1 << pin_reg);
 116               		.loc 1 31 3 is_stmt 1 view .LVU23
 117               		.loc 1 31 48 is_stmt 0 view .LVU24
 118 0058 82A1      		ldd r24,Z+34
 119 005a 8223      		and r24,r18
 120 005c 82A3      		std Z+34,r24
  32:src/gpio.c    ****         return 0;
 121               		.loc 1 32 9 is_stmt 1 view .LVU25
 122               	.LVL11:
 123               	.L12:
  33:src/gpio.c    **** 	}
  34:src/gpio.c    **** 	else
  35:src/gpio.c    **** 		*(volatile uint8_t*)(0x21 + 3 *  (port - 1)) &= ~(1 << pin_reg);
  36:src/gpio.c    **** 
  37:src/gpio.c    ****     input = (struct gpio_input*)malloc(sizeof(struct gpio_input));
  38:src/gpio.c    ****     if(input == NULL)
  39:src/gpio.c    ****         return 1;
  40:src/gpio.c    **** 
  41:src/gpio.c    ****     input->pin       = pin;
  42:src/gpio.c    ****     input->pulled_up = pulled_up;
  43:src/gpio.c    ****     list_add(&input->list, &gpio_inputs);
  44:src/gpio.c    **** 
  45:src/gpio.c    ****     return 0;
 124               		.loc 1 45 5 view .LVU26
 125               		.loc 1 45 12 is_stmt 0 view .LVU27
 126 005e 80E0      		ldi r24,0
 127 0060 00C0      		rjmp .L1
 128               	.LVL12:
 129               	.L5:
  22:src/gpio.c    ****             return 1;
 130               		.loc 1 22 9 is_stmt 1 view .LVU28
  22:src/gpio.c    ****             return 1;
 131               		.loc 1 22 11 is_stmt 0 view .LVU29
 132 0062 8081      		ld r24,Z
 133 0064 8113      		cpse r24,r17
 134 0066 00C0      		rjmp .L3
 135               	.LVL13:
 136               	.L7:
  23:src/gpio.c    ****     }
 137               		.loc 1 23 20 view .LVU30
 138 0068 81E0      		ldi r24,lo8(1)
 139               	.LVL14:
 140               	.L1:
 141               	/* epilogue start */
  46:src/gpio.c    **** }
 142               		.loc 1 46 1 view .LVU31
 143 006a DF91      		pop r29
 144 006c CF91      		pop r28
 145 006e 1F91      		pop r17
 146               	.LVL15:
 147               		.loc 1 46 1 view .LVU32
 148 0070 0F91      		pop r16
 149               	.LVL16:
 150               		.loc 1 46 1 view .LVU33
 151 0072 0895      		ret
 152               	.LVL17:
 153               	.L3:
 154               	.LBB12:
  20:src/gpio.c    ****     {
 155               		.loc 1 20 5 is_stmt 1 discriminator 2 view .LVU34
  20:src/gpio.c    ****     {
 156               		.loc 1 20 5 discriminator 2 view .LVU35
 157 0074 0784      		ldd __tmp_reg__,Z+15
 158 0076 F089      		ldd r31,Z+16
 159 0078 E02D      		mov r30,__tmp_reg__
 160               	.LVL18:
  20:src/gpio.c    ****     {
 161               		.loc 1 20 5 is_stmt 0 discriminator 2 view .LVU36
 162 007a 00C0      		rjmp .L11
 163               	.LVL19:
 164               	.L6:
  20:src/gpio.c    ****     {
 165               		.loc 1 20 5 discriminator 2 view .LVU37
 166               	.LBE12:
  35:src/gpio.c    **** 
 167               		.loc 1 35 3 is_stmt 1 view .LVU38
  35:src/gpio.c    **** 
 168               		.loc 1 35 48 is_stmt 0 view .LVU39
 169 007c 81A1      		ldd r24,Z+33
 170 007e 8223      		and r24,r18
 171 0080 81A3      		std Z+33,r24
 172               	.LVL20:
  37:src/gpio.c    ****     if(input == NULL)
 173               		.loc 1 37 5 is_stmt 1 view .LVU40
  37:src/gpio.c    ****     if(input == NULL)
 174               		.loc 1 37 33 is_stmt 0 view .LVU41
 175 0082 81E1      		ldi r24,lo8(17)
 176 0084 90E0      		ldi r25,0
 177 0086 0E94 0000 		call malloc
 178               	.LVL21:
  37:src/gpio.c    ****     if(input == NULL)
 179               		.loc 1 37 33 view .LVU42
 180 008a FC01      		movw r30,r24
 181               	.LVL22:
  38:src/gpio.c    ****         return 1;
 182               		.loc 1 38 5 is_stmt 1 view .LVU43
  38:src/gpio.c    ****         return 1;
 183               		.loc 1 38 7 is_stmt 0 view .LVU44
 184 008c 0097      		sbiw r24,0
 185 008e 01F0      		breq .L7
  41:src/gpio.c    ****     input->pulled_up = pulled_up;
 186               		.loc 1 41 5 is_stmt 1 view .LVU45
  41:src/gpio.c    ****     input->pulled_up = pulled_up;
 187               		.loc 1 41 22 is_stmt 0 view .LVU46
 188 0090 1083      		st Z,r17
  42:src/gpio.c    ****     list_add(&input->list, &gpio_inputs);
 189               		.loc 1 42 5 is_stmt 1 view .LVU47
  42:src/gpio.c    ****     list_add(&input->list, &gpio_inputs);
 190               		.loc 1 42 22 is_stmt 0 view .LVU48
 191 0092 0183      		std Z+1,r16
  43:src/gpio.c    **** 
 192               		.loc 1 43 5 is_stmt 1 view .LVU49
 193 0094 0D96      		adiw r24,13
 194               	.LVL23:
 195               	.LBB13:
 196               	.LBI13:
 197               		.file 2 "src/gpio.h"
   1:src/gpio.h    **** 
   2:src/gpio.h    **** #ifndef GPIO_H_
   3:src/gpio.h    **** #define GPIO_H_
   4:src/gpio.h    **** 
   5:src/gpio.h    **** #include <avr/io.h>
   6:src/gpio.h    **** #include <stdint.h>
   7:src/gpio.h    **** #include <stdbool.h>
   8:src/gpio.h    **** #include <stddef.h>
   9:src/gpio.h    **** #include <stdio.h>
  10:src/gpio.h    **** #include <stdlib.h>
  11:src/gpio.h    **** 
  12:src/gpio.h    **** #define GPIO_DEBOUNCE_COUNT         10
  13:src/gpio.h    **** #define GPIO_DIRECTION_INPUT        0
  14:src/gpio.h    **** #define GPIO_DIRECTION_OUTPUT       1
  15:src/gpio.h    **** 
  16:src/gpio.h    **** uint8_t gpio_register_pin(uint8_t pin, uint8_t direction, bool pulled_up);
  17:src/gpio.h    **** uint8_t gpio_read_pin(uint8_t pin);
  18:src/gpio.h    **** uint8_t gpio_write_pin(uint8_t pin, bool value);
  19:src/gpio.h    **** 
  20:src/gpio.h    **** void    gpio_debouncer(void);
  21:src/gpio.h    **** 
  22:src/gpio.h    **** struct list_head
  23:src/gpio.h    **** {
  24:src/gpio.h    ****     struct list_head* prev;
  25:src/gpio.h    ****     struct list_head* next;
  26:src/gpio.h    **** };
  27:src/gpio.h    **** 
  28:src/gpio.h    **** /*
  29:src/gpio.h    ****  *  Macro for getting address of a container which contains
  30:src/gpio.h    ****  *  a member with type 'type'
  31:src/gpio.h    ****  *  ptr: pointer to a member in a list
  32:src/gpio.h    ****  *  type: type of a structure containing the member
  33:src/gpio.h    ****  *  member: name of a member in a structure
  34:src/gpio.h    ****  *
  35:src/gpio.h    ****  *  Example:
  36:src/gpio.h    ****  *
  37:src/gpio.h    ****  *  struct gpio_chip
  38:src/gpio.h    ****  *  {
  39:src/gpio.h    ****  *      int a;
  40:src/gpio.h    ****  *      int b;
  41:src/gpio.h    ****  *      struct list_head list;
  42:src/gpio.h    ****  *  };
  43:src/gpio.h    ****  *  ...
  44:src/gpio.h    ****  *  struct list_head* gpio_element =  a structure contained inside gpio_chip
  45:src/gpio.h    ****  *  How to get an address of a container?
  46:src/gpio.h    ****  *  ->
  47:src/gpio.h    ****  *  container_of(gpio_element, struct gpio_chip, list)
  48:src/gpio.h    ****  * */
  49:src/gpio.h    **** 
  50:src/gpio.h    **** #define container_of(ptr, type, member) ({                \
  51:src/gpio.h    ****         const typeof( ((type*)0)->member)* __mptr = (ptr);  \
  52:src/gpio.h    ****         (type*)( (char*)__mptr - offsetof(type, member));   })
  53:src/gpio.h    **** 
  54:src/gpio.h    **** 
  55:src/gpio.h    **** #define LIST_HEAD(name)                                     \
  56:src/gpio.h    ****         struct list_head name = {&(name), &(name)}
  57:src/gpio.h    **** 
  58:src/gpio.h    **** #define list_empty(name)                                    \
  59:src/gpio.h    ****         name->next == name                                  \
  60:src/gpio.h    **** /*
  61:src/gpio.h    ****  * Macro to get the struct for this entry
  62:src/gpio.h    ****  * @ptr:    the struct list_head pointer
  63:src/gpio.h    ****  * @type:   type of a structure list is embedded with
  64:src/gpio.h    ****  * @member: name of struct list_head inside a structure
  65:src/gpio.h    ****  * */
  66:src/gpio.h    **** #define list_entry(ptr, type, member)                       \
  67:src/gpio.h    ****         container_of(ptr, type, member)
  68:src/gpio.h    **** 
  69:src/gpio.h    **** /*
  70:src/gpio.h    ****  * Macro to get the first element from a list.
  71:src/gpio.h    ****  * Keep in mind that lists are circular, and list is
  72:src/gpio.h    ****  * represented by a struct list_head element.
  73:src/gpio.h    ****  * For example, the way to initialize an empty list is:
  74:src/gpio.h    ****  * LIST_HEAD(list_name);
  75:src/gpio.h    ****  * Now list_name is, in fact, head of the list!
  76:src/gpio.h    ****  * It is an entry point to a list, simply a struct
  77:src/gpio.h    ****  * containing a pointer to a first and last linked-list
  78:src/gpio.h    ****  * elements.
  79:src/gpio.h    ****  * So to get the first entry, simply go to the next pointer
  80:src/gpio.h    ****  * of head.
  81:src/gpio.h    ****  */
  82:src/gpio.h    **** #define list_first_entry(ptr, type, member)                 \
  83:src/gpio.h    ****         list_entry((ptr)->next, type, member)
  84:src/gpio.h    **** 
  85:src/gpio.h    **** #define list_last_entry(ptr, type, member)                  \
  86:src/gpio.h    ****         list_entry((ptr)->prev, type, member)
  87:src/gpio.h    **** 
  88:src/gpio.h    **** /*
  89:src/gpio.h    ****  * Macro for getting the next list entry.
  90:src/gpio.h    ****  * @pos:    structure holding a struct list_head
  91:src/gpio.h    ****  * @member: name of a struct list_head inside struct 'pos'
  92:src/gpio.h    ****  */
  93:src/gpio.h    **** #define list_next_entry(pos, member)                        \
  94:src/gpio.h    ****         list_entry((pos)->member.next, typeof(*(pos)), member)
  95:src/gpio.h    **** 
  96:src/gpio.h    **** /*
  97:src/gpio.h    ****  * Macro for getting the previous list entry.
  98:src/gpio.h    ****  * @pos:    structure holding a struct list_head
  99:src/gpio.h    ****  * @member: name of a struct list_head inside struct 'pos'
 100:src/gpio.h    ****  */
 101:src/gpio.h    **** #define list_previous_entry(pos, member)                    \
 102:src/gpio.h    ****         list_entry((pos)->member.prev, typeof(*(pos)), member)
 103:src/gpio.h    **** 
 104:src/gpio.h    **** #define list_for_each(pos, head)                            \
 105:src/gpio.h    ****        for(pos = (head)->next; pos != (head); pos = pos->next)
 106:src/gpio.h    **** 
 107:src/gpio.h    **** #define list_for_each_entry(pos, head, member)              \
 108:src/gpio.h    ****     for(pos = list_first_entry(head, typeof(*pos), member); \
 109:src/gpio.h    ****         &pos->member != (head);                               \
 110:src/gpio.h    ****         pos = list_next_entry(pos, member))
 111:src/gpio.h    **** 
 112:src/gpio.h    **** static inline void __list_add(struct list_head* new,
 113:src/gpio.h    ****                               struct list_head* prev,
 114:src/gpio.h    ****                               struct list_head* next)
 115:src/gpio.h    **** {
 116:src/gpio.h    ****     next->prev = new;
 117:src/gpio.h    ****     new->next = next;
 118:src/gpio.h    ****     new->prev = prev;
 119:src/gpio.h    ****     prev->next = new;
 120:src/gpio.h    **** }
 121:src/gpio.h    **** 
 122:src/gpio.h    **** static inline void list_add(struct list_head* new, struct list_head* head)
 198               		.loc 2 122 20 view .LVU50
 199               	.LBB14:
 123:src/gpio.h    **** {
 124:src/gpio.h    ****     __list_add(new, head, head->next);
 200               		.loc 2 124 5 view .LVU51
 201 0096 A091 0000 		lds r26,gpio_inputs+2
 202 009a B091 0000 		lds r27,gpio_inputs+2+1
 203               	.LVL24:
 204               	.LBB15:
 205               	.LBI15:
 112:src/gpio.h    ****                               struct list_head* prev,
 206               		.loc 2 112 20 view .LVU52
 207               	.LBB16:
 116:src/gpio.h    ****     new->next = next;
 208               		.loc 2 116 5 view .LVU53
 116:src/gpio.h    ****     new->next = next;
 209               		.loc 2 116 16 is_stmt 0 view .LVU54
 210 009e 1196      		adiw r26,1
 211 00a0 9C93      		st X,r25
 212 00a2 8E93      		st -X,r24
 117:src/gpio.h    ****     new->prev = prev;
 213               		.loc 2 117 5 is_stmt 1 view .LVU55
 117:src/gpio.h    ****     new->prev = prev;
 214               		.loc 2 117 15 is_stmt 0 view .LVU56
 215 00a4 B08B      		std Z+16,r27
 216 00a6 A787      		std Z+15,r26
 118:src/gpio.h    ****     prev->next = new;
 217               		.loc 2 118 5 is_stmt 1 view .LVU57
 118:src/gpio.h    ****     prev->next = new;
 218               		.loc 2 118 15 is_stmt 0 view .LVU58
 219 00a8 D687      		std Z+14,r29
 220 00aa C587      		std Z+13,r28
 119:src/gpio.h    **** }
 221               		.loc 2 119 5 is_stmt 1 view .LVU59
 119:src/gpio.h    **** }
 222               		.loc 2 119 16 is_stmt 0 view .LVU60
 223 00ac 9093 0000 		sts gpio_inputs+2+1,r25
 224 00b0 8093 0000 		sts gpio_inputs+2,r24
 225 00b4 00C0      		rjmp .L12
 226               	.LBE16:
 227               	.LBE15:
 228               	.LBE14:
 229               	.LBE13:
 230               		.cfi_endproc
 231               	.LFE11:
 233               	.global	gpio_write_pin
 235               	gpio_write_pin:
 236               	.LVL25:
 237               	.LFB12:
  47:src/gpio.c    **** 
  48:src/gpio.c    **** /*
  49:src/gpio.c    ****  * 	Function:    uint8_t gpio_write_pin(uint8_t pin, bool value)
  50:src/gpio.c    ****  * 	Description: Write to a specific pin and the value of it
  51:src/gpio.c    ****  */
  52:src/gpio.c    **** uint8_t gpio_write_pin(uint8_t pin, bool value) {
 238               		.loc 1 52 49 is_stmt 1 view -0
 239               		.cfi_startproc
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
 244               		.loc 1 52 49 is_stmt 0 view .LVU62
 245 00b6 962F      		mov r25,r22
  53:src/gpio.c    **** 	uint8_t port = 1 + pin / 8;
 246               		.loc 1 53 2 is_stmt 1 view .LVU63
 247               	.LVL26:
  54:src/gpio.c    **** 	pin = pin % 8;
 248               		.loc 1 54 2 view .LVU64
  55:src/gpio.c    **** 
  56:src/gpio.c    **** 	uint8_t temp = *(volatile uint32_t*)(0x22 + 3 * (port - 1));
 249               		.loc 1 56 2 view .LVU65
  53:src/gpio.c    **** 	pin = pin % 8;
 250               		.loc 1 53 19 is_stmt 0 view .LVU66
 251 00b8 E82F      		mov r30,r24
 252 00ba E695      		lsr r30
 253 00bc E695      		lsr r30
 254 00be E695      		lsr r30
  53:src/gpio.c    **** 	pin = pin % 8;
 255               		.loc 1 53 10 view .LVU67
 256 00c0 EF5F      		subi r30,lo8(-(1))
 257               	.LVL27:
 258               		.loc 1 56 56 view .LVU68
 259 00c2 E150      		subi r30,1
 260 00c4 FF0B      		sbc r31,r31
 261               	.LVL28:
 262               		.loc 1 56 48 view .LVU69
 263 00c6 9F01      		movw r18,r30
 264 00c8 220F      		lsl r18
 265 00ca 331F      		rol r19
 266 00cc E20F      		add r30,r18
 267 00ce F31F      		adc r31,r19
 268               		.loc 1 56 17 view .LVU70
 269 00d0 42A1      		ldd r20,Z+34
 270 00d2 53A1      		ldd r21,Z+35
 271 00d4 64A1      		ldd r22,Z+36
 272 00d6 75A1      		ldd r23,Z+37
 273               	.LVL29:
  57:src/gpio.c    **** 	if(value != 0)
 274               		.loc 1 57 2 is_stmt 1 view .LVU71
 275 00d8 50E0      		ldi r21,0
  54:src/gpio.c    **** 
 276               		.loc 1 54 6 is_stmt 0 view .LVU72
 277 00da 8770      		andi r24,lo8(7)
 278               	.LVL30:
  54:src/gpio.c    **** 
 279               		.loc 1 54 6 view .LVU73
 280 00dc 21E0      		ldi r18,lo8(1)
 281 00de 30E0      		ldi r19,0
 282 00e0 00C0      		rjmp 2f
 283               		1:
 284 00e2 220F      		lsl r18
 285 00e4 331F      		rol r19
 286               		2:
 287 00e6 8A95      		dec r24
 288 00e8 02F4      		brpl 1b
 289               		.loc 1 57 4 view .LVU74
 290 00ea 9923      		tst r25
 291 00ec 01F0      		breq .L14
  58:src/gpio.c    **** 		*(volatile uint32_t*)(0x22 + 3 * (port - 1)) = temp | (1 << pin);
 292               		.loc 1 58 3 is_stmt 1 view .LVU75
 293               		.loc 1 58 55 is_stmt 0 view .LVU76
 294 00ee CA01      		movw r24,r20
 295               	.LVL31:
 296               		.loc 1 58 55 view .LVU77
 297 00f0 822B      		or r24,r18
 298 00f2 932B      		or r25,r19
 299               	.L16:
  59:src/gpio.c    **** 	else
  60:src/gpio.c    **** 		*(volatile uint32_t*)(0x22 + 3 * (port - 1)) = temp & ~(1 << pin);
 300               		.loc 1 60 55 view .LVU78
 301 00f4 092E      		mov __tmp_reg__,r25
 302 00f6 000C      		lsl r0
 303 00f8 AA0B      		sbc r26,r26
 304 00fa BB0B      		sbc r27,r27
 305               		.loc 1 60 48 view .LVU79
 306 00fc 82A3      		std Z+34,r24
 307 00fe 93A3      		std Z+35,r25
 308 0100 A4A3      		std Z+36,r26
 309 0102 B5A3      		std Z+37,r27
  61:src/gpio.c    **** 	return 0;
 310               		.loc 1 61 2 is_stmt 1 view .LVU80
  62:src/gpio.c    **** }
 311               		.loc 1 62 1 is_stmt 0 view .LVU81
 312 0104 80E0      		ldi r24,0
 313               	/* epilogue start */
 314 0106 0895      		ret
 315               	.LVL32:
 316               	.L14:
  60:src/gpio.c    **** 	return 0;
 317               		.loc 1 60 3 is_stmt 1 view .LVU82
  60:src/gpio.c    **** 	return 0;
 318               		.loc 1 60 57 is_stmt 0 view .LVU83
 319 0108 C901      		movw r24,r18
 320               	.LVL33:
  60:src/gpio.c    **** 	return 0;
 321               		.loc 1 60 57 view .LVU84
 322 010a 8095      		com r24
 323 010c 9095      		com r25
  60:src/gpio.c    **** 	return 0;
 324               		.loc 1 60 55 view .LVU85
 325 010e 8423      		and r24,r20
 326 0110 9523      		and r25,r21
 327 0112 00C0      		rjmp .L16
 328               		.cfi_endproc
 329               	.LFE12:
 331               	.global	gpio_read_pin
 333               	gpio_read_pin:
 334               	.LVL34:
 335               	.LFB14:
  63:src/gpio.c    **** 
  64:src/gpio.c    **** /*
  65:src/gpio.c    ****  * 	Function: static uint8_t __gpio_read_pin(uint8_t pin)
  66:src/gpio.c    ****  */
  67:src/gpio.c    **** static uint8_t __gpio_read_pin(uint8_t pin) {
  68:src/gpio.c    ****     uint8_t port = 1 + pin / 8;
  69:src/gpio.c    ****     pin = pin % 8;
  70:src/gpio.c    **** 
  71:src/gpio.c    **** 	uint8_t temp = (*((volatile uint8_t*)(0x20 + 3 * (port - 1))));
  72:src/gpio.c    **** 
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
  74:src/gpio.c    **** }
  75:src/gpio.c    **** 
  76:src/gpio.c    **** /*
  77:src/gpio.c    ****  * 	Function:    uint8_t gpio_read_pin(uint8_t pin)
  78:src/gpio.c    ****  * 	Description: reading the state of a pin
  79:src/gpio.c    ****  */
  80:src/gpio.c    **** uint8_t gpio_read_pin(uint8_t pin) {
 336               		.loc 1 80 36 is_stmt 1 view -0
 337               		.cfi_startproc
 338               	/* prologue: function */
 339               	/* frame size = 0 */
 340               	/* stack size = 0 */
 341               	.L__stack_usage = 0
  81:src/gpio.c    ****     struct gpio_input* input;
 342               		.loc 1 81 5 view .LVU87
  82:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
 343               		.loc 1 82 5 view .LVU88
 344               	.LBB17:
 345               		.loc 1 82 5 view .LVU89
 346               		.loc 1 82 5 view .LVU90
 347 0114 E091 0000 		lds r30,gpio_inputs+2
 348 0118 F091 0000 		lds r31,gpio_inputs+2+1
 349               	.L33:
 350               		.loc 1 82 5 is_stmt 0 view .LVU91
 351               	.LBE17:
 352               	.LBB18:
 353               		.loc 1 82 5 discriminator 2 view .LVU92
 354 011c 3D97      		sbiw r30,13
 355               	.LVL35:
 356               		.loc 1 82 5 discriminator 2 view .LVU93
 357               	.LBE18:
 358 011e 90E0      		ldi r25,hi8(gpio_inputs-13)
 359 0120 E030      		cpi r30,lo8(gpio_inputs-13)
 360 0122 F907      		cpc r31,r25
 361 0124 01F4      		brne .L25
  83:src/gpio.c    ****     {
  84:src/gpio.c    ****         if(pin == input->pin)
  85:src/gpio.c    ****         {
  86:src/gpio.c    ****             uint8_t i = 0;
  87:src/gpio.c    ****             while(i < GPIO_DEBOUNCE_COUNT - 1)
  88:src/gpio.c    ****             {
  89:src/gpio.c    ****                 if(input->values[i] != input->values[i + 1])
  90:src/gpio.c    ****                     return input->previous_state;
  91:src/gpio.c    ****                 i++;
  92:src/gpio.c    ****             }
  93:src/gpio.c    **** 
  94:src/gpio.c    ****             uint8_t state = input->pulled_up == false ? (input->values[0]) : !(input->values[0]);
  95:src/gpio.c    ****             input->previous_state = state;
  96:src/gpio.c    **** 
  97:src/gpio.c    ****             return state;
  98:src/gpio.c    ****         }
  99:src/gpio.c    ****     }
 100:src/gpio.c    **** 
 101:src/gpio.c    ****     return 1;
 362               		.loc 1 101 12 view .LVU94
 363 0126 81E0      		ldi r24,lo8(1)
 364               	.LVL36:
 365               	/* epilogue start */
 102:src/gpio.c    **** }
 366               		.loc 1 102 1 view .LVU95
 367 0128 0895      		ret
 368               	.LVL37:
 369               	.L25:
  84:src/gpio.c    ****         {
 370               		.loc 1 84 9 is_stmt 1 view .LVU96
  84:src/gpio.c    ****         {
 371               		.loc 1 84 11 is_stmt 0 view .LVU97
 372 012a 9081      		ld r25,Z
 373 012c 9813      		cpse r25,r24
 374 012e 00C0      		rjmp .L19
 375 0130 DF01      		movw r26,r30
 376 0132 1296      		adiw r26,2
 377 0134 CF01      		movw r24,r30
 378               	.LVL38:
  84:src/gpio.c    ****         {
 379               		.loc 1 84 11 view .LVU98
 380 0136 0B96      		adiw r24,11
 381               	.L22:
 382               	.LVL39:
 383               	.LBB19:
  89:src/gpio.c    ****                     return input->previous_state;
 384               		.loc 1 89 17 is_stmt 1 view .LVU99
  89:src/gpio.c    ****                     return input->previous_state;
 385               		.loc 1 89 33 is_stmt 0 view .LVU100
 386 0138 3D91      		ld r19,X+
 387               	.LVL40:
  89:src/gpio.c    ****                     return input->previous_state;
 388               		.loc 1 89 19 view .LVU101
 389 013a 2C91      		ld r18,X
 390 013c 3217      		cp r19,r18
 391 013e 01F0      		breq .L20
  90:src/gpio.c    ****                 i++;
 392               		.loc 1 90 21 is_stmt 1 view .LVU102
  90:src/gpio.c    ****                 i++;
 393               		.loc 1 90 33 is_stmt 0 view .LVU103
 394 0140 8485      		ldd r24,Z+12
 395 0142 0895      		ret
 396               	.L20:
  91:src/gpio.c    ****             }
 397               		.loc 1 91 17 is_stmt 1 view .LVU104
 398               	.LVL41:
  87:src/gpio.c    ****             {
 399               		.loc 1 87 18 is_stmt 0 view .LVU105
 400 0144 A817      		cp r26,r24
 401 0146 B907      		cpc r27,r25
 402 0148 01F4      		brne .L22
  94:src/gpio.c    ****             input->previous_state = state;
 403               		.loc 1 94 13 is_stmt 1 view .LVU106
 404 014a 8281      		ldd r24,Z+2
  94:src/gpio.c    ****             input->previous_state = state;
 405               		.loc 1 94 21 is_stmt 0 view .LVU107
 406 014c 9181      		ldd r25,Z+1
 407 014e 9923      		tst r25
 408 0150 01F0      		breq .L23
  94:src/gpio.c    ****             input->previous_state = state;
 409               		.loc 1 94 78 discriminator 2 view .LVU108
 410 0152 91E0      		ldi r25,lo8(1)
 411 0154 8111      		cpse r24,__zero_reg__
 412 0156 90E0      		ldi r25,0
 413               	.L24:
  94:src/gpio.c    ****             input->previous_state = state;
 414               		.loc 1 94 21 discriminator 2 view .LVU109
 415 0158 892F      		mov r24,r25
 416               	.L23:
 417               	.LVL42:
  95:src/gpio.c    **** 
 418               		.loc 1 95 13 is_stmt 1 discriminator 4 view .LVU110
  95:src/gpio.c    **** 
 419               		.loc 1 95 35 is_stmt 0 discriminator 4 view .LVU111
 420 015a 8487      		std Z+12,r24
  97:src/gpio.c    ****         }
 421               		.loc 1 97 13 is_stmt 1 discriminator 4 view .LVU112
  97:src/gpio.c    ****         }
 422               		.loc 1 97 20 is_stmt 0 discriminator 4 view .LVU113
 423 015c 0895      		ret
 424               	.LVL43:
 425               	.L19:
  97:src/gpio.c    ****         }
 426               		.loc 1 97 20 discriminator 4 view .LVU114
 427               	.LBE19:
 428               	.LBB20:
  82:src/gpio.c    ****     {
 429               		.loc 1 82 5 is_stmt 1 discriminator 2 view .LVU115
  82:src/gpio.c    ****     {
 430               		.loc 1 82 5 discriminator 2 view .LVU116
 431 015e 0784      		ldd __tmp_reg__,Z+15
 432 0160 F089      		ldd r31,Z+16
 433 0162 E02D      		mov r30,__tmp_reg__
 434               	.LVL44:
  82:src/gpio.c    ****     {
 435               		.loc 1 82 5 is_stmt 0 discriminator 2 view .LVU117
 436 0164 00C0      		rjmp .L33
 437               	.LBE20:
 438               		.cfi_endproc
 439               	.LFE14:
 441               	.global	gpio_debouncer
 443               	gpio_debouncer:
 444               	.LFB15:
 103:src/gpio.c    **** 
 104:src/gpio.c    **** /*
 105:src/gpio.c    ****  * 	Function:    void gpio_debouncer(void)
 106:src/gpio.c    ****  * 	Description: debouncer function, used for triggering inputs smoothly
 107:src/gpio.c    ****  */
 108:src/gpio.c    **** void gpio_debouncer(void) {
 445               		.loc 1 108 27 is_stmt 1 view -0
 446               		.cfi_startproc
 447 0166 CF93      		push r28
 448               	.LCFI4:
 449               		.cfi_def_cfa_offset 3
 450               		.cfi_offset 28, -2
 451 0168 DF93      		push r29
 452               	.LCFI5:
 453               		.cfi_def_cfa_offset 4
 454               		.cfi_offset 29, -3
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 2 */
 458               	.L__stack_usage = 2
 109:src/gpio.c    ****     static volatile uint8_t count = 0;
 459               		.loc 1 109 5 view .LVU119
 110:src/gpio.c    ****     struct gpio_input* input;
 460               		.loc 1 110 5 view .LVU120
 111:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
 461               		.loc 1 111 5 view .LVU121
 462               	.LBB25:
 463               		.loc 1 111 5 view .LVU122
 464               	.LVL45:
 465               		.loc 1 111 5 view .LVU123
 466 016a E091 0000 		lds r30,gpio_inputs+2
 467 016e F091 0000 		lds r31,gpio_inputs+2+1
 468               	.LVL46:
 469               	.L38:
 470               		.loc 1 111 5 is_stmt 0 view .LVU124
 471               	.LBE25:
 472               	.LBB26:
 473               		.loc 1 111 5 discriminator 3 view .LVU125
 474 0172 3D97      		sbiw r30,13
 475               	.LVL47:
 476               		.loc 1 111 5 discriminator 3 view .LVU126
 477               	.LBE26:
 478 0174 D0E0      		ldi r29,hi8(gpio_inputs-13)
 479 0176 E030      		cpi r30,lo8(gpio_inputs-13)
 480 0178 FD07      		cpc r31,r29
 481 017a 01F4      		brne .L36
 112:src/gpio.c    ****     {
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 114:src/gpio.c    ****     }
 115:src/gpio.c    **** 
 116:src/gpio.c    ****     if(++count == GPIO_DEBOUNCE_COUNT)
 482               		.loc 1 116 5 is_stmt 1 view .LVU127
 483               		.loc 1 116 8 is_stmt 0 view .LVU128
 484 017c 8091 0000 		lds r24,count.1994
 485 0180 8F5F      		subi r24,lo8(-(1))
 486               		.loc 1 116 7 view .LVU129
 487 0182 8093 0000 		sts count.1994,r24
 488 0186 8A30      		cpi r24,lo8(10)
 489 0188 01F4      		brne .L34
 117:src/gpio.c    ****         count = 0;
 490               		.loc 1 117 9 is_stmt 1 view .LVU130
 491               		.loc 1 117 15 is_stmt 0 view .LVU131
 492 018a 1092 0000 		sts count.1994,__zero_reg__
 493               	.L34:
 494               	/* epilogue start */
 118:src/gpio.c    **** 
 119:src/gpio.c    **** }...
 495               		.loc 1 119 1 view .LVU132
 496 018e DF91      		pop r29
 497 0190 CF91      		pop r28
 498 0192 0895      		ret
 499               	.L36:
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 500               		.loc 1 113 9 is_stmt 1 discriminator 3 view .LVU133
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 501               		.loc 1 113 32 is_stmt 0 discriminator 3 view .LVU134
 502 0194 2081      		ld r18,Z
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 503               		.loc 1 113 22 discriminator 3 view .LVU135
 504 0196 A091 0000 		lds r26,count.1994
 505               	.LVL48:
 506               	.LBB27:
 507               	.LBI27:
  67:src/gpio.c    **** static uint8_t __gpio_read_pin(uint8_t pin) {
 508               		.loc 1 67 16 is_stmt 1 discriminator 3 view .LVU136
 509               	.LBB28:
  68:src/gpio.c    ****     uint8_t port = 1 + pin / 8;
 510               		.loc 1 68 5 discriminator 3 view .LVU137
  69:src/gpio.c    ****     pin = pin % 8;
 511               		.loc 1 69 5 discriminator 3 view .LVU138
  71:src/gpio.c    **** 	uint8_t temp = (*((volatile uint8_t*)(0x20 + 3 * (port - 1))));
 512               		.loc 1 71 2 discriminator 3 view .LVU139
  68:src/gpio.c    ****     uint8_t port = 1 + pin / 8;
 513               		.loc 1 68 22 is_stmt 0 discriminator 3 view .LVU140
 514 019a 822F      		mov r24,r18
 515 019c 8695      		lsr r24
 516 019e 8695      		lsr r24
 517 01a0 8695      		lsr r24
  68:src/gpio.c    ****     uint8_t port = 1 + pin / 8;
 518               		.loc 1 68 13 discriminator 3 view .LVU141
 519 01a2 8F5F      		subi r24,lo8(-(1))
 520               	.LVL49:
  71:src/gpio.c    **** 	uint8_t temp = (*((volatile uint8_t*)(0x20 + 3 * (port - 1))));
 521               		.loc 1 71 57 discriminator 3 view .LVU142
 522 01a4 8150      		subi r24,1
 523 01a6 990B      		sbc r25,r25
 524               	.LVL50:
  71:src/gpio.c    **** 	uint8_t temp = (*((volatile uint8_t*)(0x20 + 3 * (port - 1))));
 525               		.loc 1 71 49 discriminator 3 view .LVU143
 526 01a8 AC01      		movw r20,r24
 527 01aa 440F      		lsl r20
 528 01ac 551F      		rol r21
 529 01ae 840F      		add r24,r20
 530 01b0 951F      		adc r25,r21
  71:src/gpio.c    **** 	uint8_t temp = (*((volatile uint8_t*)(0x20 + 3 * (port - 1))));
 531               		.loc 1 71 10 discriminator 3 view .LVU144
 532 01b2 EC01      		movw r28,r24
 533 01b4 88A1      		ldd r24,Y+32
 534               	.LVL51:
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
 535               		.loc 1 73 5 is_stmt 1 discriminator 3 view .LVU145
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
 536               		.loc 1 73 5 is_stmt 0 discriminator 3 view .LVU146
 537               	.LBE28:
 538               	.LBE27:
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 539               		.loc 1 113 30 discriminator 3 view .LVU147
 540 01b6 AE0F      		add r26,r30
 541 01b8 BF2F      		mov r27,r31
 542 01ba B11D      		adc r27,__zero_reg__
 543               	.LBB30:
 544               	.LBB29:
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
 545               		.loc 1 73 19 discriminator 3 view .LVU148
 546 01bc 90E0      		ldi r25,0
  69:src/gpio.c    ****     pin = pin % 8;
 547               		.loc 1 69 9 discriminator 3 view .LVU149
 548 01be 2770      		andi r18,lo8(7)
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
 549               		.loc 1 73 19 discriminator 3 view .LVU150
 550 01c0 00C0      		rjmp 2f
 551               		1:
 552 01c2 9595      		asr r25
 553 01c4 8795      		ror r24
 554               		2:
 555 01c6 2A95      		dec r18
 556 01c8 02F4      		brpl 1b
  73:src/gpio.c    ****     return ((temp >> pin) & 0x01);
 557               		.loc 1 73 27 discriminator 3 view .LVU151
 558 01ca 8170      		andi r24,lo8(1)
 559               	.LBE29:
 560               	.LBE30:
 113:src/gpio.c    ****         input->values[count] = __gpio_read_pin(input->pin);
 561               		.loc 1 113 30 discriminator 3 view .LVU152
 562 01cc 1296      		adiw r26,2
 563 01ce 8C93      		st X,r24
 564               	.LBB31:
 111:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
 565               		.loc 1 111 5 is_stmt 1 discriminator 3 view .LVU153
 566               	.LVL52:
 111:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
 567               		.loc 1 111 5 discriminator 3 view .LVU154
 568 01d0 0784      		ldd __tmp_reg__,Z+15
 569 01d2 F089      		ldd r31,Z+16
 570 01d4 E02D      		mov r30,__tmp_reg__
 571               	.LVL53:
 111:src/gpio.c    ****     list_for_each_entry(input, &gpio_inputs, list)
 572               		.loc 1 111 5 is_stmt 0 discriminator 3 view .LVU155
 573 01d6 00C0      		rjmp .L38
 574               	.LBE31:
 575               		.cfi_endproc
 576               	.LFE15:
 578               		.local	count.1994
 579               		.comm	count.1994,1,1
 580               	.global	gpio_inputs
 581               		.data
 584               	gpio_inputs:
 585 0000 0000      		.word	gpio_inputs
 586 0002 0000      		.word	gpio_inputs
 587               		.text
 588               	.Letext0:
 589               		.file 3 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdint.h"
 590               		.file 4 "/usr/local/Cellar/avr-gcc/8.3.0/lib/avr-gcc/8/gcc/avr/8.3.0/include/stddef.h"
 591               		.file 5 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdio.h"
 592               		.file 6 "/usr/local/Cellar/avr-gcc/8.3.0/avr/include/stdlib.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 gpio.c
/var/tmp//ccGBukle.s:2      *ABS*:000000000000003e __SP_H__
/var/tmp//ccGBukle.s:3      *ABS*:000000000000003d __SP_L__
/var/tmp//ccGBukle.s:4      *ABS*:000000000000003f __SREG__
/var/tmp//ccGBukle.s:5      *ABS*:000000000000003b __RAMPZ__
/var/tmp//ccGBukle.s:6      *ABS*:0000000000000000 __tmp_reg__
/var/tmp//ccGBukle.s:7      *ABS*:0000000000000001 __zero_reg__
/var/tmp//ccGBukle.s:13     .text:0000000000000000 gpio_register_pin
/var/tmp//ccGBukle.s:584    .data:0000000000000000 gpio_inputs
/var/tmp//ccGBukle.s:235    .text:00000000000000b6 gpio_write_pin
/var/tmp//ccGBukle.s:333    .text:0000000000000114 gpio_read_pin
/var/tmp//ccGBukle.s:443    .text:0000000000000166 gpio_debouncer
                             .bss:0000000000000000 count.1994

UNDEFINED SYMBOLS
malloc
__do_copy_data
__do_clear_bss
